[{"title":"面向对象基础","url":"/2019/03/26/面向对象基础/","content":"\n​\t重温《大话设计模式》，本页笔记采用中文编写，以复习Python的目的，大多数设计模式会用Python实现。在开始实现具体模式前，首先了解一下设计模式六大原则\n\n## 六大原则\n\n- **单一职责原则**（Single responsibility principles, SRP ），规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来，实现不同类的解耦。\n- **开放封闭原则**（Open close principles, OCP），软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。\n- **里氏替换原则**（Liskov substitution principles, LSP），派生类（子类）对象可以在程式中代替其基类（超类）对象。\n- **依赖倒置原则**（Dependency Inversion principles, DIP），是指一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。如适配器模式。\n- **接口隔离原则**（Interface-segregation principles, ISP），指明客户应该不依赖于它不使用的方法。ISP拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。\n- **最少知识原则**（又称迪米特法则，Law of demeter, LoD）很多面向对象程序设计语言用\".\"表示对象的域的解析算符，因此得墨忒耳定律可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。（引用自[维基百科：得墨忒耳定律](<https://zh.wikipedia.org/wiki/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B>)）\n\n\n## 创见型模式\n\n## 结构型模式\n\n### 装饰者模式\n\n有两种方式可以实现给一个类或对象增加行为：\n\n- 继承，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。\n- 关联，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)\n\n装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。\n\n例子：[装饰模式简例](https://wanghaomao.github.io/2019/03/25/Python-Decorator-and-Decorator-Pattern/)\n\n\n\n\n## 行为型模式\n\n## 引用\n\n[1] 程杰 大话设计模式[M] 北京：清华大学出版社 2010\n\n[2] [https://zh.wikipedia.org](https://zh.wikipedia.org/)\n\n[3] <https://design-patterns.readthedocs.io/zh_CN/latest/>\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Design Pattern"]},{"title":"Python Decorator @ and Decorator Pattern","url":"/2019/03/25/Python-Decorator-and-Decorator-Pattern/","content":"\n## Decorator @ in Python\n\nWe want to modify its behavior by introspecting or rewriting some part of the class(or method) definition, but we don't want to use inheritance or metaclasses. \n\nThis situation may be the best use case for class decorators. For example, here is a class decorator that overrides the special method `__getattribute__` to print the log:\n\n```python\ndef log_getattribute(cls):\n    # Get the original implementation\n    orig_getattribute = cls.__getattribute__\n\n    # Make a new definition\n    def new_getattribute(self, name):\n        print('getting:', name)\n        return orig_getattribute(self, name)\n\n    # Attach to the class and return\n    cls.__getattribute__ = new_getattribute\n    return cls\n\n# Example use\n@log_getattribute\nclass A:\n    def __init__(self,x):\n        self.x = x\n    def spam(self):\n        pass\n```\n\n@ Above is from The Original in Python Cookbook\n\n\n\nIn particular, we can use decorators to add functionality to a particular function in a class.\n\n```python\ndef new_behavior(cls):\n    # Get attr or method\n    orig_getattribute = getattr(cls, \"spam2\")\n\n    # Make a new definition, (*args, **kw) will keep any parameters\n    def new_getattribute(*args):\n        print('new behavior in ', end=\" \")\n        return orig_getattribute(args)\n\n    setattr(cls, \"spam2\", new_getattribute)\n    return cls\n\n\n# Example use\n@new_behavior\nclass A:\n    def __init__(self, x):\n        self.x = x\n\n    def spam(self):\n        print(\"spam 1\")\n\n    def spam2(self):\n        print(\"spam 2\")\n\n\nif __name__ == '__main__':\n    a = A(42)\n    a.spam()\n    a.spam2()\n```\n\n\n\n## Decorator Pattern\n\n```python\n\"\"\"\nhttps://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html\n\n实例：变形金刚\n主要目的为基类（在不破坏封闭原则基础上）增加功能，代码中fly() 和 say()方法\n缺点（或是有待完善的地方）：直接使用构造函数装饰（代替装饰方法）不易于构造基类\n\n后续更新另一个例子，使用装饰方法装饰\n\"\"\"\nimport abc\n\n\nclass Transform:\n    def __init__(self):\n        pass\n\n    def move(self):\n        print(\"Transform can move\")\n\n\nclass Car(Transform):\n    def __init__(self):\n        super().__init__()\n\n    def move(self):\n        print(\"Car is moving\", end=\" \")\n\n\nclass Changer(Transform, metaclass=abc.ABCMeta):\n    __transform: Transform\n\n    def __init__(self, transform):\n        super().__init__()\n        self.__transform = transform\n\n    @abc.abstractmethod\n    def move(self):\n        if self.__transform:\n            self.__transform.move()\n\n\nclass Robot(Changer):\n    def __init__(self, transform):\n        super().__init__(transform)\n        print(\"Change to Robot\")\n\n    def move(self):\n        super().move()\n        print(\"Robot is moving\", end=\" \")\n\n    #  新行为\n    def say(self):\n        print(\"Robot would say something\")\n\n\nclass AirPort(Changer):\n    def __init__(self, transform):\n        super().__init__(transform)\n        print(\"Change to Air Port\")\n\n    def move(self):\n        super().move()\n        print(\"AirPort is moving\", end=\" \")\n\n    #  新行为\n    def fly(self):\n        print('Air port can fly')\n\n\nif __name__ == '__main__':\n\n    Bumblebee = Transform()\n    Bumblebee.move()\n    Bumblebee = AirPort(Bumblebee)\n    # Bumblebee.move()\n    # Bumblebee = Robot(Bumblebee)\n    # Bumblebee.say()\n    Bumblebee.fly()\n\n    Bumblebee.move()\n```\n\n\n\n## Reference\n\n[1] [Python Cookbook 3rd Edition](https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p12_using_decorators_to_patch_class_definitions.html)\n\n","tags":["Design Pattern"]},{"title":"Apache Flink Notebook","url":"/2019/03/22/Apache-Flink-Notebook/","content":"\nRecently, I am learning the usage of Apache Flink. In this note, I would like to write down some notes of Flink and distributed computing. (this page is updating)\n\n## Basic\n\n### What is Apache Flink\n\nApache Flink is an open source **stream processing framework**, which is a **distributed streaming dataflow engine** written in Java and Scala.\n\n\n\n### Domain\n\nEvent-driven Applications【事件驱动】\nData Analytics Applications【数据分析】\nData Pipeline Applications【管道式ETL】\n\n### Compare with Apache Spark(Spark Streaming)\n\n\n\n\n|                              | Micro-Batching                                               | Distributed Snapshots                                        |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| Implantation                 | Apache Spark                                                 | Apache Flink                                                 |\n| Semantics                    | Exactly-Once (To process every message once and only once)   | Exactly-Once                                                 |\n| Delay                        | High                                                         | Low                                                          |\n| Storm                  | High                                                         | High                                                         |\n| Computing Model              | Micro Batch                                                  | Streaming                                                    |\n| Fault Tolerant               | Low                                                          | Low                                                          |\n| Flow control                 | Relatively Bad                                               | Good                                                         |\n| Business and Fault-tolerance | Relatively Coupling                                          | Separation                                                   |\n|                              | Continuous data streams should not be split to the record level, but converged into a batch of micro-batch, atomic data for batch-like calculations. | Determine the state of the current flow calculation (including the data being processed, and the Operator state), generate a consistent snapshot of the state, and store it in persistent storage |\n\n\n\n## Reference\n\n[1] 李飞 进阶教程-Flink大数据项目实战（上，下）","tags":["Flink"]},{"title":"Priority Queue Implementation","url":"/2019/03/18/Priority-queue-Implementation/","content":"In this page, I create a class Binary Heap to implement priority queue in C++ and Python. The data structure is same in both programing language as below,\n\n```sql\n* vector(list in python) to store data\n* if i is current node:\n* 2*i + 1 is the first child, and 2 * i + 2 is right child\n* (i - 1) / 2 is the father node\n```\n\nIn C++, I impment compare function(amp) to maintain priority of the heap. we also can provide self-define  compare function(amp).\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n/***\n * vector to store data\n * if i is current node:\n * 2*i + 1 is the first child, and 2 * i + 2 is right child\n * (i - 1) / 2 is the father node\n ***/\ntypedef unsigned long ul;\ntemplate<class T>\nclass BinaryHeap{\npublic:\n    BinaryHeap();\n    explicit BinaryHeap(vector<T>);\n    explicit BinaryHeap(bool (*cmp)(const T&, const T&));\n    explicit BinaryHeap(vector<T>,bool (*cmp)(const T&, const T&));\n\n    bool insert(T ele);\n    void show_queue(){\n        for(T x : elements){\n            cout << x << \" \";\n        }\n        cout << endl;\n    }\n    T pop_top();\n    bool empty();\nprivate:\n    vector<T> elements;\n    unsigned long heap_size;\n    bool (*cmp)(T ele_a, T ele_b);\n\n    void shift_up(T, ul);\n    void shift_down(T, ul);\n    bool build_heap();\n    static bool default_cmp(T ele_a, T ele_b);\n};\n\ntemplate<class T>\nBinaryHeap<T>::BinaryHeap() {\n    heap_size = 0;\n    this->cmp = default_cmp;\n}\ntemplate<class T>\nBinaryHeap<T>::BinaryHeap(bool (*cmp)(const T&, const T&)) {\n    heap_size = 0;\n    this->cmp = cmp;\n}\ntemplate<class T>\nBinaryHeap<T>::BinaryHeap(vector<T> eles):elements(move(eles)) {\n    heap_size = elements.size();\n    this->cmp = default_cmp;\n    build_heap();\n}\n\ntemplate<class T>\nBinaryHeap<T>::BinaryHeap(vector<T> eles, bool (*cmp)(const T&, const T&)):elements(move(eles)){\n    heap_size = elements.size();\n    build_heap();\n    this->cmp = cmp;\n}\n\ntemplate<class T>\nbool BinaryHeap<T>::insert(T ele) {\n    elements.push_back(ele);\n    heap_size++;\n\n    shift_up(ele,heap_size-1);\n\n    return true;\n}\n\ntemplate<class T>\nT BinaryHeap<T>::pop_top() {\n    if(heap_size <= 0) throw exception();\n\n    T leave = elements[--heap_size];\n    T top = elements[0];\n    elements.pop_back();\n\n    if(heap_size > 1)\n        shift_down(leave,0);\n    return top;\n}\n\ntemplate<class T>\nbool BinaryHeap<T>::empty() {\n    return heap_size == 0;\n}\n\ntemplate<class T>\nbool BinaryHeap<T>::build_heap() {\n    if(heap_size == 0) return true;\n\n    unsigned long _first_not_leave = (heap_size - 1) / 2;\n    for(ul i = _first_not_leave; i >= 0;i--){\n        shift_down(elements[i],i);\n        if(i == 0) break; // necessary because unsigned long won't reach -1\n    }\n}\ntemplate<class T>\nbool BinaryHeap<T>::default_cmp(T ele_a, T ele_b) {\n    return ele_a < ele_b;\n}\n\ntemplate<class T>\nvoid BinaryHeap<T>::shift_up(T ele, ul pos) {\n    ul i = pos,j = (pos - 1) / 2;\n    while(i > 0 and cmp(ele,elements[j])){\n        elements[i] = elements[j];\n        i = j;j = (i - 1) / 2;\n    }\n    elements[i] = ele;\n}\ntemplate<class T>\nvoid BinaryHeap<T>::shift_down(T ele, ul pos) {\n    ul i = pos, j = pos * 2 + 1;\n    while(j < heap_size){\n        if(j+1 < heap_size && cmp(elements[j+1],elements[j])) j = j+1;\n        if(cmp(ele,elements[j])) break;\n        elements[i] = elements[j];\n        i = j; j = i*2 + 1;\n    }\n    elements[i] = ele;\n}\nint main() {\n\n    vector<int> v{4,6,8,7,4,2,4};\n    auto *hp = new BinaryHeap<int>(v);\n\n    while(!hp->empty()){\n        cout << hp->pop_top() <<\" \";\n    }\n    cout << endl;\n    return 0;\n}\n```\n\nThe Python version is relatively poor than the previous one. I will enhance it in the future.\n\n```python\n# utf-8\n# coding in python 3.6\nclass PriortyQue:\n    \"\"\"\n    # README\n    # 使用list存储二叉树\n    # 大根堆，最大元素在顶端（弹出最大元素）,注释部分为维护小根堆\n    # i结点的父结点位置为(i-1)//2，i结点的左右子结点位置为2*i+1和2*i+2\n    # 叶子节点 length//2 - 1\n    \"\"\"\n    def __init__(self, elements):\n        # 用列表存储树结构\n        self.elements = list(elements)\n\n        # 构建树\n        if not self.empty():\n            leng = len(self.elements)\n            for i in range(leng // 2 - 1, -1, -1):\n                print(i, leng)\n                self.arrangeDown(self.elements[i], i, leng)\n\n    # 判断是否为空\n    def empty(self):\n        return True if self.elements == [] else False\n\n    # 添加元素\n    def push(self, ele):\n        self.elements.append(ele)\n        self.arrangeUp(ele, len(self.elements) - 1)\n\n    # 推出元素\n    def pop(self):\n        if self.empty():\n            print(\"Empty Error\")\n            return\n\n        elif len(self.elements) == 1:\n            return self.elements.pop()\n\n        cp_elements = self.elements\n        root = self.elements[0]\n        ele = cp_elements.pop()\n        if cp_elements is not []:\n            self.arrangeDown(ele, 0, len(cp_elements))\n\n        return root\n\n    \"\"\"\n    维护大根堆\n    \"\"\"\n    def arrangeDown(self, ele, begin, end):\n\n        cp_elements = self.elements\n        i = begin\n        j = begin * 2 + 1\n\n        while j < end:\n            # 当前元素已经为三个元素中的最大值\n            if j + 1 < end and ele > max(cp_elements[j], cp_elements[j + 1]):\n                break\n            if j + 1 < end and cp_elements[j] < cp_elements[j + 1]:\n                j += 1\n            cp_elements[i] = cp_elements[j]\n            i = j\n            j = i * 2 + 1\n\n        cp_elements[i] = ele\n\n    def arrangeUp(self, ele, last):\n        cp_elements = self.elements\n        i = last\n        j = (last - 1) // 2\n\n        while i > 0 and ele > cp_elements[j]:\n            cp_elements[i] = cp_elements[j]\n            i = j\n            j = (i - 1) // 2\n\n        cp_elements[i] = ele\n        \nif __name__ == '__main__':\n    \"\"\"\n    Data test\n    \"\"\"\n    priorityQue = PriortyQue([4,6,8,7,4,2,4])\n    # priorityQue = PriortyQue([1])\n    print(priorityQue.elements)\n    print(priorityQue.pop())\n    print(priorityQue.elements)\n    priorityQue.push(100)\n\n    while not priorityQue.empty():\n        print(priorityQue.pop(), end=' ')\n```\n\n","tags":["python"]},{"title":"PySpark-SparkGraphX","url":"/2018/12/12/PySpark-SparkGraphX/","content":"\nIn this article, I will share some knowledge about PySpark SparkGraphX. At beginning, I would like to paste some classes materials.\n\n```\n\n\n\n\n```\n\n","tags":["PySpark"]},{"title":"py-mysql-csv tools","url":"/2018/11/06/py-mysql-csv-tools/","content":"\nNow, I start to do my indenpendent project about house price prediction, the raw data are stored in mysql database, but most of time, I would like to use csv file to do machine learning practise. \n\nIt's really a long time to code without database, so I decide to write down those scripts, which are related about selecting sql and saving data  into csv file. Sometimes, especailly there are characters not in English like Chinese, we need to do encode/decode excutions. Let's start with install py-mysql.\n\n## Install py-mysql\n\n```\npip install py-mysql\n```\n\n[Document links here](https://pypi.org/project/py-mysql/)\n\n## Connect with Database\n\n```python\nimport mysql.connector\n# fill base info of my mysql database\nmydb = mysql.connector.connect(user='username', \t\n                               password='password',\t\n                               host='127.0.0.1',\n                               database='databaseName')\nmycursor = mydb.cursor()\n```\n\n```python\nsql = \"SELECT * FROM Table_Name\nmycursor.execute(sql)\nmyresult = mycursor.fetchall()\n```\n\n[more dabase sql info here](https://www.w3schools.com/python/python_mysql_getstarted.asp)\n\n```python\n# columns name\ncol_names = [i[0] for i in mycursor.description]\nfor row in myresult:\n    print(row)\n```\n\n## Save(Write) to CSV \n\n```python\nimport csv\n# It works to me to write Chinese data to csv for unrecognizable code problem\n# encoding='utf-8-sig'\ncsv_train_file = open('train.csv','w', newline='',encoding='utf-8-sig')\nwriter = csv.writer(csv_train_file)\nwriter.writerow(col_names)\nfor row in myresult:\n    writer.writerow(list(row))\ncsv_train_file.close()\nprint('finished..')\n```\n\n","tags":["python"]},{"title":"Review in C++ std","url":"/2018/10/21/Review-in-C-std/","content":"\nIt's a long time not to practice C and C++ language,  for remember std containers, write this article to introduce like std::vector, std::map, std::set, etc.\n\n## std::vector\n\n","tags":["C++"]},{"title":"Gcc in Mac OS","url":"/2018/10/21/Gcc-in-Mac-OS/","content":"\nDefaultly, our g++ compiler in Mac OS with installing by XCode are too old, it may not be efficient or convenient for us in some situations. So easily to update(change) it by Homebrew.\n\ncurrent version of gcc is gcc-8, which may take much time to download.\n\n```\nbrew install gcc\n```\n\nAfter installation, our new gcc location is  **/usr/local/bin/**.\nActually, our default location is **/usr/bin/**, but the computer will check the **/usr/local/bin/** before another one, so it works.\n\n```\ncd /usr/local/bin/\nrm cc gcc c++ g++\nln -s /usr/local/bin/gcc-8 cc\nln -s /usr/local/bin/gcc-8 gcc\nln -s /usr/local/bin/c++-8 c++\nln -s /usr/local/bin/g++-8 g++\n```\n\nTips, if  we dowload another new gcc, use the same code above and change the version like g++-6 to switch the default one.","tags":["C++"]},{"title":"PySpark-SparkSQL","url":"/2018/10/17/PySpark-SparkSQL/","content":"\nThe first time to touch with Spark in **MS 5003 Big Data Computing** in HKUST, and this is an article for recording SparkSQL experence or tutorials. I will add SparkRDD and Spark ML in later articles.\n\n## SQL review\n\nAdd later..\n\n## SparkSQL\n\n#### Initialization\n\n**basic import & Initialization** \n\n```python\n# row\nfrom pyspark.sql import Row\n\nrow = Row(name=\"Alice\", age=11)\nprint row['name'], row['age']\nprint row.name, row.age\nrow = Row(name=\"Alice\", age=11, count=1)\nprint row.count #<built-in method count of Row object at 0x10d446b30>\nprint row['count'] #1, recommended\n```\n\n\n\n```python\n# SparkSession,pyspark.sql.SparkSession(sparkContext, jsparkSession=None)\n# inherit sparkContext\nfrom pyspark.sql import SparkSession\n# initial set up a SparkSession\nspark = SparkSession.builder\\\n        .appName(\"Python Spark SQL basic example\")\\\n        .config(\"spark.some.config.option\", \"some-value\")\\\n        .getOrCreate()\n \ndf = spark.read.csv('../data/building.csv', header=True, inferSchema=True)\n# also can read text, etc\nlines = spark.read.text('../data/adj_noun_pairs.txt')\ndf.printSchema()\n# output\nroot\n |-- BuildingID: integer (nullable = true)\n |-- BuildingMgr: string (nullable = true)\n |-- BuildingAge: integer (nullable = true)\n |-- HVACproduct: string (nullable = true)\n |-- Country: string (nullable = true)\n# Create an RDD from the dataframe\ndfrdd = df.rdd\n# dfrdd.take(3)\ndfrdd.take(3)\n```\n\n\n\n```python\n# function\nfrom pyspark.sql.functions import *\n```\n\n#### SparkSQL(Dataframe) Operations\n\n```python\n# table example\nroot\n |-- BuildingID: integer (nullable = true)\n |-- BuildingMgr: string (nullable = true)\n |-- BuildingAge: integer (nullable = true)\n |-- HVACproduct: string (nullable = true)\n |-- Country: string (nullable = true)\n```\n\n**Select**\n\n```python\n# spark are defined before.\ndf = spark.read.csv('data.csv')\n# select columns\ndf.select('BuildingID', 'Country')\ndf.select('HVACproduct')\n# select column and rename\ndf.select(col('Country').alias('myCounrty'))\n# select calculated columns\ndf.select((col('BuildingID') * col('BuildingAge')).alias('newColumn'))\ndf.select(log(col('BuildingID') * col('BuildingAge'))) # free to use python script here\n# e.g. another example\npairs = words.select(words['w'][0].alias('adj'), words['w'][1].alias('noun'))\n# select with where/filter\ndf.where(\"Country = 'Finland'\").select('*')\ndf.where(\"Country like 'F%'\").select('*', lit('OK')) # pyspark.sql.functions.lit(col) -- Creates a Column of literal value.\n```\n\n**GroupBy & Aggregation**\n\n```python\n# for each country, count the number.\ndf.groupBy('Country').count()\n# for each country, find the total Price.\n# same as rdd.map(lambda Country:(Country,Price)).reduceByKey(lambda:f1,f2:f1+f2)\ndf.groupBy('Country').sum('Price')\n# orderBy\ndf.groupBy('Country').sum('Price').orderBy()\ndf.groupBy('Country').sum('Price').orderBy(desc('sum(Price)')) # descrising\n```\n\n\n\n#### Tutorials\n\n**PageRank**\n\n```python\n#data example\npagerank_data.txt\n1 2\n1 3\n2 3\n3 4\n4 1\n2 1\nlinks.show()\n+---+---+\n|src|dst|\n+---+---+\n|  1|  2|\n|  1|  3|\n|  2|  3|\n|  3|  4|\n|  4|  1|\n|  2|  1|\n+---+---+\nranks.show()\n+---+----+\n|src|rank|\n+---+----+\n|  3|   1|\n|  1|   1|\n|  4|   1|\n|  2|   1|\n+---+----+\noutdegrees.show()\n+---+-----+\n|src|count|\n+---+-----+\n|  3|    1|\n|  1|    2|\n|  4|    1|\n|  2|    2|\n+---+-----+\n```\n\n\n\n```python\nfrom pyspark.sql.functions import *\nfrom pyspark.sql import SparkSession\nspark = SparkSession.builder\\\n        .appName(\"Python Spark SQL basic example\")\\\n        .config(\"spark.some.config.option\", \"some-value\")\\\n        .getOrCreate()\n\nnumOfIterations = 10\nlines = spark.read.text(\"pagerank_data.txt\")\n# You can also test your program on the follow larger data set:\n# lines = spark.read.text(\"dblp.in\")\n\na = lines.select(split(lines[0],' '))\nlinks = a.select(a[0][0].alias('src'), a[0][1].alias('dst'))\noutdegrees = links.groupBy('src').count()\nranks = outdegrees.select('src', lit(1).alias('rank'))\n\nfor iteration in range(numOfIterations):\n    # FILL IN THIS PART\n    # PR(u) = part1 + part2\n    # PR(u) = 0.15 + 0.85 * sum(all(PR(v)/outdegrees(v))), v -> u\n    contributors = links.join(ranks,'src')\\\n                        .join(outdegrees,'src')\\\n                        .select('dst',(col('rank')/col('count'))\\\n                        .alias('partition'))\n    \n    contributors = contributors.withColumnRenamed('dst', 'dst1')\\\n                               .groupBy('dst1')\\\n                               .sum('partition')\n    \n    ranks = contributors.select(col('dst1').alias('src'),round(0.15+0.85*col('sum(partition)'),3).alias('rank'))\n  \nranks.orderBy(desc('rank')).show()\n```\n\n**PMI**\n\n\n\n#### Bugs & Errors\n\nNote: There is a bug in the current SparkSQL implementation: The groupBy (followed by some aggregation) method sometimes fails to group all rows with the same key.  A temporary workaround is the following:\n\nSuppose you want to do\n\n```python\ndf.groupBy('A').sum('B')\n```\n\nIf it fails to produce the desired result, try\n\n```python\ndf.withColumnRenamed('A', 'A1').groupBy('A1').sum('B')\n```\n\nThe professor reported this bug to the Spark developers and the issue is currently under investigation:\n\nhttps://issues.apache.org/jira/browse/SPARK-20169 ","tags":["PySpark"]},{"title":"CS229ML Notebook","url":"/2018/10/16/CS229ML-Notebook/","content":"\nMatrix (Multiple features) in Machine Learning\n\n\n\nNueral Networks\n\na<sup>i+1</sup> = g( theta<sup>i</sup> *  x)","tags":["Machine Learning"]},{"title":"Python-Packages Recorders","url":"/2018/10/16/Python-Packages-Recorders/","content":"\n Write down some useful python tools or packages used in works and projects.\n\n###Country/Region & Currency Related\n\n**Locale to Currency name**\n\n[Babel](http://babel.pocoo.org/en/latest/) and locale\n\n```python\n# e.g. zh_CN--> RNY, zh_HK --> Hong Kong Dollar\ndef get_currency(loc):\n    locale.setlocale(locale.LC_ALL, loc)\n    sym = locale.localeconv()['int_curr_symbol']\n    # print(babel.numbers.format_currency(1099.98,sym))\n    return babel.numbers.get_currency_name(sym)\n    \nget_currency('zh_HK')\nCNY\nget_currency('en_US')\nHong Kong Dollar\nget_currency('zh_CN')\nUSD\n```\n\n**Exchange Rate** \n\nforex-python(https://pypi.org/project/forex-python/)\n\n```python\n# Date time (Oct 16th, 2018)\n# Data from https://ratesapi.io/api/\nfrom forex_python.converter import CurrencyRates\nc=CurrencyRates()\nc.get_rate('HKD','CNY')\n0.8829\n\nc.get_rates('HKD')\n{'AUD': 0.1788, 'BGN': 0.2155, 'BRL': 0.4792, 'CAD': 0.1662, 'CHF': 0.1259, 'CNY': 0.8829, 'CZK': 2.8422, 'DKK': 0.822, 'EUR': 0.1102, 'GBP': 0.097, 'HRK': 0.8168, 'HUF': 35.6352, 'IDR': 1940.6502, 'ILS': 0.4628, 'INR': 9.4168, 'ISK': 14.8292, 'JPY': 14.2706, 'KRW': 144.0623, 'MXN': 2.4039, 'MYR': 0.5303, 'NOK': 1.0422, 'NZD': 0.1953, 'PHP': 6.9022, 'PLN': 0.4731, 'RON': 0.5142, 'RUB': 8.3647, 'SEK': 1.1449, 'SGD': 0.1757, 'THB': 4.169, 'TRY': 0.7366, 'USD': 0.1276, 'ZAR': 1.8413}\n\n```","tags":["python"]},{"title":"GitHub Related","url":"/2018/10/15/GitHub-Related/","content":"\n\n\n## Scripts\n\n```\n$ git clone\n\n$ git add .\n\n$ git commit -m 'commitment'\n\n$ git push\n```\n\n\n\n## Eorrors\n\n1. Github permission denied(403) error when push commits over https (on MacOS) \n\n   no permission to ...user1...git to user2\n\n```\n1. Remove all data related to github stored in \n$ cd /Applications/utilities/keychain access.app\n# delete all github related redcoders\n# or go to Applications/utilities/ and open keychain access.app,\n\n$ cd ~/.ssh/\n# delete all github related redcoders\n\n2. try again\n```\n\n","tags":["GitHub"]},{"title":"Hexo(My Blog) Supplement","url":"/2018/10/15/Hexo-My-Blog-Supplement/","content":"\nMy blog is built supported by [hexo](https://hexo.io/) , and there is a sample copy of [github guidline](https://github.com/hexojs/hexo) as a self dictionary for avoiding missing.\n\nBlog display set: [https://wanghaomao.github.io/](https://wanghaomao.github.io/)\n\nBut blog in folder my_hexo_folder: [https://github.com/WangHaomao/my_hexo_folder](https://github.com/WangHaomao/my_hexo_folder)\n\n###Installation\n\n```\n$ npm install hexo-cli -g\n```\n\n###Quick Start\n\n**Setup your blog**\n\n```\n$ hexo init blog\n$ cd blog\n```\n\n**Start the server**\n\n```\n$ hexo server\n```\n\n**Create a new post**\n\n```\n$ hexo new \"Hello Hexo\"\n```\n\n**Generate **\n\n```\n$ hexo generate\n```\n\n**Submit **\n\n```\n$ hexo clean\n$ hexo deploy\n```\n\n**Errors & Current Theme**\n\n1. Errors \n\n```\ndeployer not found:git\n$ npm install hexo-deployer-git --save\n```\n\n2. Current theme\n  Very SImple: [https://github.com/lotabout/very-simple](https://github.com/lotabout/very-simple)"},{"title":"Ubuntu 与 Mac os 终端代理","url":"/2018/01/07/Ubuntu 与 Mac os 终端代理/","content":"\n主要使用SS(shadowsocks)做代理，在Ubuntu和大多数Linux中可以安装SS-qt图形化界面使用，当然使用 Python 脚本的 SS也是比较方便的; 在Mac os中，SS也可以在互联网上下载。使用其他方式对系统代理后，以下终端代理方法仍适用\n\n注：SS的安装此处不提及，请访问其他相关页面\n\n## Ubuntu\n在Ubuntu中，推荐使用 proxychains\n安装比较简单，同时速度也不错，配置也相对简单，以下是安装使用过程：\n\nproxychains 仓库地址： https://github.com/rofl0r/proxychains-ng\n详细配置与安装上述网站中有提及，如下\n#### 1、下载安装\n```bash\n$ git clone https://github.com/rofl0r/proxychains-ng.git\n$ cd proxychains-ng\n#以下命令需要GCC环境，仓库地址中有提及\n#needs a working C compiler, preferably gcc\n$ sudo make install \n$ sudo make install-config (installs proxychains.conf)\n\n```\n#### 2、完善配置文件\n```bash\n$ sudo vim /etc/proxychains.conf\n#找到[ProxyList] 后，添加代理信息，SS使用socks5，如果用http代理可使用http\nsocks5  127.0.0.1 1080 \n```\n#### 3、测试与使用\n可以使用wget 测试 google.com 页面\nproxychains 的用法是在需要使用的命令前加 proxychains4 ，例：\n\n```bash\n$ proxychains4 wget google.com\n$ sudo proxychains4 [your shell]\n```\n## Mac os\n\n\n","tags":["Linux"]},{"title":"我的博客搬家了","url":"/2018/01/07/我的博客搬家了/","content":"\n\n本科快毕业了，买的学生服务器和域名也快到期了，所以搬到了Github下的免费博客，新年新气象～。Hexo框架的博客，我比较喜欢简洁风格，所以选择了这个画风，正好熟悉一下markdown格式。\n\n博客文章正在搬运的路上 ...\n\n\n\n\n\n## 以下是原 Hello Word 信息\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["Lives"]},{"title":"GeoSpider分布式爬虫","url":"/2017/11/13/GeoSpider分布式爬虫/","content":"\n**GeoSpider** 是一款适用于结构化抓取新闻博客、电商类网站的分布式爬虫。系统可对新闻网站，绝大多数的博客和电商网站进行数据自动摘录。采用多进程辅佐分布式的并发方式，提高采集效率。总体使用Psutil进行进程、Scrapy-Redis作分布式与管理、MonoDB作数据存储。爬虫任务可设定启动时间、选择主机IP等。兴趣爱好与参加中国软件杯。\n\n视频链接 https://www.bilibili.com/video/av12055194/?from=search&seid=13360983049365681598\n\n## 主要功能\n本节主要介绍 **GeoSpider** 的基本功能，包括数据的抓取、状态监控和简单的数据分析等等\n\n### 1. 数据抓取\n **GeoSpider** 是一个为爬虫系统，旨在高效、准确地抓取网络页面中的数据\n\n### 2. 爬虫状态监控\n使用Graphite监控所有爬虫任务，能够监控到爬虫的下载速率、爬去数据数量等，并绘制成图像显示出来。\n爬虫启动后，每台主机会启动一个监听进程来监听定时进程，将即将到达结束时间的进程终止。\n\n\n### 3. 数据分析\n1.堆叠条形图：统计正在进行爬虫任务的数量信息，分别统计电商爬虫、新闻爬虫、博客爬虫分别运行、暂停、等待、故障的数量。\n2.饼状图：统计历史爬虫（已经结束的爬虫）电商、新闻、博客的数量比例。\n3.阶梯折线图：统计最近一周时间电商、新闻、博客爬虫任务的数量走向。\n3.雷达图：最有价值的图。统计当前每台机器的爬虫进程数量，用户可以很清晰的获知爬虫任务在每台机器上的分布情况，因此可以分析出每台机器的负荷，为用户下次发布任务提供指导。\n\n## 设计思路\n### 1. 电商类网站结构化\n#### 1.1、导航栏抓取\n返回值：列表（标签:url），例如：（裙子:http://www.xxx.com/qunzi）\n##### 设计思路概述\n主要思想是是渐进的特征提取，以关键字聚类作为辅助。\n\n关键字聚类：预先设计好电商网站的导航栏关键字，其次对Web网页中某个结构进行多次匹配，计算得分，得分越高聚类程度越强，选优者作为导航栏，存在一定误差和少量不足。\n\n#### 方法概述\n以下方法按照顺序执行，上一个方法不成功则进行下一个，理论依据暂不明确。\n通过“所有商品分类”、“商品分类”、“分类”等关键字的特征值提取，获取大分类页面。若该步成功，跳转到 xx 步继续执行\n提取特征：class = *nav*，并进行关键词匹配\n提取特征：tag_name = ul，并进行关键词匹配\n方法1.2.2与方法1.2.3提取获得的结果将进行再一次的导航栏抓取，由于二级页面可能存在大分类页面或是母标签的扩展标签，尽可能的多提取标签与url。\n上述方法都不适用（暂未遇到），拟计划提醒消息，手动输入class或id或其他特征值进行抓取\n\n【注】:获取大分类所有标签（1.1扩展）\n主要思想：标签树序列化，聚类后获取量值最优解，选作结果集\n\n标签树序列化后对形态：html/body/div/div/ul/li/a\n#### 1.2、导航链接解析（抓取详细页面链接\n（此模块可归为第一步，由于相对复杂，单独列项）\n对于第一步（导航栏抓取）拿到的 (名词:url)列表，称为url_list，进行第一遍遍历。\n分支一\n如果名词（关键字）在url中出现，就可以做关键词查询操作（例如我们平常在购物网站购物时做的那样）\n\n（此处需要对该名词的选择还是比较考究的，最好选择有list/search字样的url，选择不慎可能出现大量url没有商品信息的问题。）\n\n1.1 选择较优的url，简称为orignal_url，并对url做如下操作\n步骤一：用&分割, split(‘&’)\n步骤二：拼接字符串，获得包括关键字在内的近-最简的url，此处需要对url进行拼接试探。获取简化\t\t后的url，以下简称simple_url。\n步骤三：对 simple_url 进行解析，包括翻页信息、关键字替换信息等等。\n步骤四：对url_list进行第二遍遍历，将里面关键字在simple_url中替换，得到res_url_list\n\n拼接试探：先获取包括url在内的最简化的url，简称为simple_url。利用request等方法测试其html数量上与orignal_url用request获得的数量，若减少量巨大，接上其他由&分割的字串，继续测试。\n\n分支二\n如果名词（关键词）始终没有在url中出现（或不符合要求）\n直接默认这些url为商品列表，直接规划为res_url_list\n\n#### 1.3、解析商品列表页面\n【注】：在遍历之前最好对分支二得到的res_url_list做一遍聚类处理，对每一类进行一遍结构化\n\n进行具体结构化，获取商品的详细页面链接，思路如下：\n1、判断该网址中的存储类型，以此选择解析方法：\n通过html中的字符串数量判断，共分为以下3中解析方式：\n1.1、JSON解析方法（request），主要商品数据在JSON中\n1.2、标签解析方法（request），数据不在Json中，在标签中可直接提取\n1.3、标签解析方法（webdriver），数据不在Json中，通过request无法获得，借用webdriver获取标签\n\n上述步骤主要获取商品详细页面的url，并进行一定的提取，例如价格、描述等等\n\n\n#### 1.4、商品详细页面分析\n\n通过对关键词的提取，预先设置关键词的先后顺序，不断匹配html标签中的信息，结构化出内容。例如匹配商品价格时，首先查找\n\n\n### 2. 新闻博客类网站结构化\n新闻博客抽取算法是采用基于行块分布，或者叫基于文本密度的方法，并在该方法上再做了优化，在我们自己设计的测试下，准确率达到95以上。\n对于新闻博客类网站，一般文字内容最集中的区域就是正文。但是也不尽然，有些新闻正文很短，而导航栏内容信息很多。\n首先，过滤噪声标签等的影响。采用正则过滤掉ul、script、style、注释等内容，记下该内容，然后过滤所有标签，再标记该内容。\n然后定义k行为一个行块，去掉空格的长度为行块长度。根据行块分布找出最密集的区域则为正文内容。\n该正文内容已经基本正确，但是如果该正文区域下方或前方不远处出现小部分无关内容，也会计入正文内容，导致有稍许误差。\n为了提高准确率，在去掉噪声的网页中全文搜索包含在已提取的正文中的块信息，一般为“p“标签，再计算得到该标签的父节点。\n将所有获得的父节点存储下来，出现次数最多的父节点标签即为包含整个正文区域的标签。直接从该标签提取文字即为正文。\n该过程失败则使用之前提取的正文，成功则使用该区域提取的文字作为正文。\n### 3. 分布式与多进程概述\n各机器之间的通信借助Redis的订阅发布功能，订阅了爬虫频道的从机才能够收到主机的信息，解析主机的命令，然后控制机器自己上面的爬虫程序。\n主机根据用户需求，向指定的从机发送控制爬虫的命令（启动、暂停、唤醒、终止）和该爬虫任务需要启动的进程数量。从机通过控制进程来控制爬虫。\n\n### 4. 错误恢复机制\n机器监听到本机上的爬虫由于异常即将终止程序时，该机器会清空本机的所有任务，根据任务记录启动新的爬虫程序继续之前未完成的任务。\n已爬取过的链接由于已经存储下来，所有重新启动爬虫后会进行URL判重，不会抓取到重复的链接。\n\n\n## 主要框架与依赖\n> * Scrapy\n> * 发布日记，杂文，所见所想\n> * 撰写发布技术文稿（代码支持）\n> * 撰写发布学术论文（LaTeX 公式支持）","tags":["Projects"]},{"title":"Echarts 与 百度地图API 初步使用","url":"/2017/06/06/Echarts 与 百度地图API 初步使用/","content":"\n由于要做一个数据的统计（微博等社交网络的流行病分析），借用echarts开源统计项目做一个简单的数据可视化，大致效果如下链接\nhttp://echarts.baidu.com/demo.html#effectScatter-bmap\n\n以下是我实现后的效果图，代码很简单，但还是折腾了很久。（div的height数据千万记得写）。不同的演示效果和数据可以在上述网站中找到。\n\n<div align=center>\n<img src=\"/images/20170606_1.png\" >\n</div>\n\n下面是很长的代码：\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<title>ECharts map Demo</title>\n<script type=\"text/javascript\" src=\"js/jquery-2.2.3.min.js\"></script>\n<script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=2.0&ak=你的AK秘钥\"></script>\n\n</head>\n\n<body>\n    <div id=\"main\" style=\"height:960px; width:auto;\"></div>\n\n<script src=\"dist/echarts.js\"></script>\n<!-- 引入百度地图扩展 -->\n<script src=\"dist/extension/bmap.min.js\"></script>\n<script>\n\nvar myChart = echarts.init(document.getElementById('main'));\nvar data = [\n     {name: '海门', value: 9},\n     {name: '鄂尔多斯', value: 12},\n     {name: '招远', value: 12},\n     {name: '舟山', value: 12},\n     {name: '齐齐哈尔', value: 14},\n     {name: '盐城', value: 15},\n     {name: '赤峰', value: 16},\n     {name: '青岛', value: 18},\n     {name: '乳山', value: 18},\n     {name: '金昌', value: 19},\n     {name: '泉州', value: 21},\n     {name: '莱西', value: 21},\n     {name: '日照', value: 21},\n     {name: '胶南', value: 22},\n     {name: '南通', value: 23},\n     {name: '拉萨', value: 24},\n     {name: '云浮', value: 24},\n     {name: '梅州', value: 25},\n     {name: '文登', value: 25},\n     {name: '上海', value: 25},\n     {name: '攀枝花', value: 25},\n     {name: '威海', value: 25},\n     {name: '承德', value: 25},\n     {name: '厦门', value: 26},\n     {name: '汕尾', value: 26},\n     {name: '潮州', value: 26},\n     {name: '丹东', value: 27},\n     {name: '太仓', value: 27},\n     {name: '曲靖', value: 27},\n     {name: '烟台', value: 28},\n     {name: '福州', value: 29},\n     {name: '瓦房店', value: 30},\n     {name: '即墨', value: 30},\n     {name: '抚顺', value: 31},\n     {name: '玉溪', value: 31},\n     {name: '张家口', value: 31},\n     {name: '阳泉', value: 31},\n     {name: '莱州', value: 32},\n     {name: '湖州', value: 32},\n     {name: '汕头', value: 32},\n     {name: '昆山', value: 33},\n     {name: '宁波', value: 33},\n     {name: '湛江', value: 33},\n     {name: '揭阳', value: 34},\n     {name: '荣成', value: 34},\n     {name: '连云港', value: 35},\n     {name: '葫芦岛', value: 35},\n     {name: '常熟', value: 36},\n     {name: '东莞', value: 36},\n     {name: '河源', value: 36},\n     {name: '淮安', value: 36},\n     {name: '泰州', value: 36},\n     {name: '南宁', value: 37},\n     {name: '营口', value: 37},\n     {name: '惠州', value: 37},\n     {name: '江阴', value: 37},\n     {name: '蓬莱', value: 37},\n     {name: '韶关', value: 38},\n     {name: '嘉峪关', value: 38},\n     {name: '广州', value: 38},\n     {name: '延安', value: 38},\n     {name: '太原', value: 39},\n     {name: '清远', value: 39},\n     {name: '中山', value: 39},\n     {name: '昆明', value: 39},\n     {name: '寿光', value: 40},\n     {name: '盘锦', value: 40},\n     {name: '长治', value: 41},\n     {name: '深圳', value: 41},\n     {name: '珠海', value: 42},\n     {name: '宿迁', value: 43},\n     {name: '咸阳', value: 43},\n     {name: '铜川', value: 44},\n     {name: '平度', value: 44},\n     {name: '佛山', value: 44},\n     {name: '海口', value: 44},\n     {name: '江门', value: 45},\n     {name: '章丘', value: 45},\n     {name: '肇庆', value: 46},\n     {name: '大连', value: 47},\n     {name: '临汾', value: 47},\n     {name: '吴江', value: 47},\n     {name: '石嘴山', value: 49},\n     {name: '沈阳', value: 50},\n     {name: '苏州', value: 50},\n     {name: '茂名', value: 50},\n     {name: '嘉兴', value: 51},\n     {name: '长春', value: 51},\n     {name: '胶州', value: 52},\n     {name: '银川', value: 52},\n     {name: '张家港', value: 52},\n     {name: '三门峡', value: 53},\n     {name: '锦州', value: 54},\n     {name: '南昌', value: 54},\n     {name: '柳州', value: 54},\n     {name: '三亚', value: 54},\n     {name: '自贡', value: 56},\n     {name: '吉林', value: 56},\n     {name: '阳江', value: 57},\n     {name: '泸州', value: 57},\n     {name: '西宁', value: 57},\n     {name: '宜宾', value: 58},\n     {name: '呼和浩特', value: 58},\n     {name: '成都', value: 58},\n     {name: '大同', value: 58},\n     {name: '镇江', value: 59},\n     {name: '桂林', value: 59},\n     {name: '张家界', value: 59},\n     {name: '宜兴', value: 59},\n     {name: '北海', value: 60},\n     {name: '西安', value: 61},\n     {name: '金坛', value: 62},\n     {name: '东营', value: 62},\n     {name: '牡丹江', value: 63},\n     {name: '遵义', value: 63},\n     {name: '绍兴', value: 63},\n     {name: '扬州', value: 64},\n     {name: '常州', value: 64},\n     {name: '潍坊', value: 65},\n     {name: '重庆', value: 66},\n     {name: '台州', value: 67},\n     {name: '南京', value: 67},\n     {name: '滨州', value: 70},\n     {name: '贵阳', value: 71},\n     {name: '无锡', value: 71},\n     {name: '本溪', value: 71},\n     {name: '克拉玛依', value: 72},\n     {name: '渭南', value: 72},\n     {name: '马鞍山', value: 72},\n     {name: '宝鸡', value: 72},\n     {name: '焦作', value: 75},\n     {name: '句容', value: 75},\n     {name: '北京', value: 79},\n     {name: '徐州', value: 79},\n     {name: '衡水', value: 80},\n     {name: '包头', value: 80},\n     {name: '绵阳', value: 80},\n     {name: '乌鲁木齐', value: 84},\n     {name: '枣庄', value: 84},\n     {name: '杭州', value: 84},\n     {name: '淄博', value: 85},\n     {name: '鞍山', value: 86},\n     {name: '溧阳', value: 86},\n     {name: '库尔勒', value: 86},\n     {name: '安阳', value: 90},\n     {name: '开封', value: 90},\n     {name: '济南', value: 92},\n     {name: '德阳', value: 93},\n     {name: '温州', value: 95},\n     {name: '九江', value: 96},\n     {name: '邯郸', value: 98},\n     {name: '临安', value: 99},\n     {name: '兰州', value: 99},\n     {name: '沧州', value: 100},\n     {name: '临沂', value: 103},\n     {name: '南充', value: 104},\n     {name: '天津', value: 105},\n     {name: '富阳', value: 106},\n     {name: '泰安', value: 112},\n     {name: '诸暨', value: 112},\n     {name: '郑州', value: 113},\n     {name: '哈尔滨', value: 114},\n     {name: '聊城', value: 116},\n     {name: '芜湖', value: 117},\n     {name: '唐山', value: 119},\n     {name: '平顶山', value: 119},\n     {name: '邢台', value: 119},\n     {name: '德州', value: 120},\n     {name: '济宁', value: 120},\n     {name: '荆州', value: 127},\n     {name: '宜昌', value: 130},\n     {name: '义乌', value: 132},\n     {name: '丽水', value: 133},\n     {name: '洛阳', value: 134},\n     {name: '秦皇岛', value: 136},\n     {name: '株洲', value: 143},\n     {name: '石家庄', value: 147},\n     {name: '莱芜', value: 148},\n     {name: '常德', value: 152},\n     {name: '保定', value: 153},\n     {name: '湘潭', value: 154},\n     {name: '金华', value: 157},\n     {name: '岳阳', value: 169},\n     {name: '长沙', value: 175},\n     {name: '衢州', value: 177},\n     {name: '廊坊', value: 193},\n     {name: '菏泽', value: 194},\n     {name: '合肥', value: 229},\n     {name: '武汉', value: 273},\n     {name: '大庆', value: 279}\n];\nvar geoCoordMap = {\n    '海门':[121.15,31.89],\n    '鄂尔多斯':[109.781327,39.608266],\n    '招远':[120.38,37.35],\n    '舟山':[122.207216,29.985295],\n    '齐齐哈尔':[123.97,47.33],\n    '盐城':[120.13,33.38],\n    '赤峰':[118.87,42.28],\n    '青岛':[120.33,36.07],\n    '乳山':[121.52,36.89],\n    '金昌':[102.188043,38.520089],\n    '泉州':[118.58,24.93],\n    '莱西':[120.53,36.86],\n    '日照':[119.46,35.42],\n    '胶南':[119.97,35.88],\n    '南通':[121.05,32.08],\n    '拉萨':[91.11,29.97],\n    '云浮':[112.02,22.93],\n    '梅州':[116.1,24.55],\n    '文登':[122.05,37.2],\n    '上海':[121.48,31.22],\n    '攀枝花':[101.718637,26.582347],\n    '威海':[122.1,37.5],\n    '承德':[117.93,40.97],\n    '厦门':[118.1,24.46],\n    '汕尾':[115.375279,22.786211],\n    '潮州':[116.63,23.68],\n    '丹东':[124.37,40.13],\n    '太仓':[121.1,31.45],\n    '曲靖':[103.79,25.51],\n    '烟台':[121.39,37.52],\n    '福州':[119.3,26.08],\n    '瓦房店':[121.979603,39.627114],\n    '即墨':[120.45,36.38],\n    '抚顺':[123.97,41.97],\n    '玉溪':[102.52,24.35],\n    '张家口':[114.87,40.82],\n    '阳泉':[113.57,37.85],\n    '莱州':[119.942327,37.177017],\n    '湖州':[120.1,30.86],\n    '汕头':[116.69,23.39],\n    '昆山':[120.95,31.39],\n    '宁波':[121.56,29.86],\n    '湛江':[110.359377,21.270708],\n    '揭阳':[116.35,23.55],\n    '荣成':[122.41,37.16],\n    '连云港':[119.16,34.59],\n    '葫芦岛':[120.836932,40.711052],\n    '常熟':[120.74,31.64],\n    '东莞':[113.75,23.04],\n    '河源':[114.68,23.73],\n    '淮安':[119.15,33.5],\n    '泰州':[119.9,32.49],\n    '南宁':[108.33,22.84],\n    '营口':[122.18,40.65],\n    '惠州':[114.4,23.09],\n    '江阴':[120.26,31.91],\n    '蓬莱':[120.75,37.8],\n    '韶关':[113.62,24.84],\n    '嘉峪关':[98.289152,39.77313],\n    '广州':[113.23,23.16],\n    '延安':[109.47,36.6],\n    '太原':[112.53,37.87],\n    '清远':[113.01,23.7],\n    '中山':[113.38,22.52],\n    '昆明':[102.73,25.04],\n    '寿光':[118.73,36.86],\n    '盘锦':[122.070714,41.119997],\n    '长治':[113.08,36.18],\n    '深圳':[114.07,22.62],\n    '珠海':[113.52,22.3],\n    '宿迁':[118.3,33.96],\n    '咸阳':[108.72,34.36],\n    '铜川':[109.11,35.09],\n    '平度':[119.97,36.77],\n    '佛山':[113.11,23.05],\n    '海口':[110.35,20.02],\n    '江门':[113.06,22.61],\n    '章丘':[117.53,36.72],\n    '肇庆':[112.44,23.05],\n    '大连':[121.62,38.92],\n    '临汾':[111.5,36.08],\n    '吴江':[120.63,31.16],\n    '石嘴山':[106.39,39.04],\n    '沈阳':[123.38,41.8],\n    '苏州':[120.62,31.32],\n    '茂名':[110.88,21.68],\n    '嘉兴':[120.76,30.77],\n    '长春':[125.35,43.88],\n    '胶州':[120.03336,36.264622],\n    '银川':[106.27,38.47],\n    '张家港':[120.555821,31.875428],\n    '三门峡':[111.19,34.76],\n    '锦州':[121.15,41.13],\n    '南昌':[115.89,28.68],\n    '柳州':[109.4,24.33],\n    '三亚':[109.511909,18.252847],\n    '自贡':[104.778442,29.33903],\n    '吉林':[126.57,43.87],\n    '阳江':[111.95,21.85],\n    '泸州':[105.39,28.91],\n    '西宁':[101.74,36.56],\n    '宜宾':[104.56,29.77],\n    '呼和浩特':[111.65,40.82],\n    '成都':[104.06,30.67],\n    '大同':[113.3,40.12],\n    '镇江':[119.44,32.2],\n    '桂林':[110.28,25.29],\n    '张家界':[110.479191,29.117096],\n    '宜兴':[119.82,31.36],\n    '北海':[109.12,21.49],\n    '西安':[108.95,34.27],\n    '金坛':[119.56,31.74],\n    '东营':[118.49,37.46],\n    '牡丹江':[129.58,44.6],\n    '遵义':[106.9,27.7],\n    '绍兴':[120.58,30.01],\n    '扬州':[119.42,32.39],\n    '常州':[119.95,31.79],\n    '潍坊':[119.1,36.62],\n    '重庆':[106.54,29.59],\n    '台州':[121.420757,28.656386],\n    '南京':[118.78,32.04],\n    '滨州':[118.03,37.36],\n    '贵阳':[106.71,26.57],\n    '无锡':[120.29,31.59],\n    '本溪':[123.73,41.3],\n    '克拉玛依':[84.77,45.59],\n    '渭南':[109.5,34.52],\n    '马鞍山':[118.48,31.56],\n    '宝鸡':[107.15,34.38],\n    '焦作':[113.21,35.24],\n    '句容':[119.16,31.95],\n    '北京':[116.46,39.92],\n    '徐州':[117.2,34.26],\n    '衡水':[115.72,37.72],\n    '包头':[110,40.58],\n    '绵阳':[104.73,31.48],\n    '乌鲁木齐':[87.68,43.77],\n    '枣庄':[117.57,34.86],\n    '杭州':[120.19,30.26],\n    '淄博':[118.05,36.78],\n    '鞍山':[122.85,41.12],\n    '溧阳':[119.48,31.43],\n    '库尔勒':[86.06,41.68],\n    '安阳':[114.35,36.1],\n    '开封':[114.35,34.79],\n    '济南':[117,36.65],\n    '德阳':[104.37,31.13],\n    '温州':[120.65,28.01],\n    '九江':[115.97,29.71],\n    '邯郸':[114.47,36.6],\n    '临安':[119.72,30.23],\n    '兰州':[103.73,36.03],\n    '沧州':[116.83,38.33],\n    '临沂':[118.35,35.05],\n    '南充':[106.110698,30.837793],\n    '天津':[117.2,39.13],\n    '富阳':[119.95,30.07],\n    '泰安':[117.13,36.18],\n    '诸暨':[120.23,29.71],\n    '郑州':[113.65,34.76],\n    '哈尔滨':[126.63,45.75],\n    '聊城':[115.97,36.45],\n    '芜湖':[118.38,31.33],\n    '唐山':[118.02,39.63],\n    '平顶山':[113.29,33.75],\n    '邢台':[114.48,37.05],\n    '德州':[116.29,37.45],\n    '济宁':[116.59,35.38],\n    '荆州':[112.239741,30.335165],\n    '宜昌':[111.3,30.7],\n    '义乌':[120.06,29.32],\n    '丽水':[119.92,28.45],\n    '洛阳':[112.44,34.7],\n    '秦皇岛':[119.57,39.95],\n    '株洲':[113.16,27.83],\n    '石家庄':[114.48,38.03],\n    '莱芜':[117.67,36.19],\n    '常德':[111.69,29.05],\n    '保定':[115.48,38.85],\n    '湘潭':[112.91,27.87],\n    '金华':[119.64,29.12],\n    '岳阳':[113.09,29.37],\n    '长沙':[113,28.21],\n    '衢州':[118.88,28.97],\n    '廊坊':[116.7,39.53],\n    '菏泽':[115.480656,35.23375],\n    '合肥':[117.27,31.86],\n    '武汉':[114.31,30.52],\n    '大庆':[125.03,46.58]\n};\n\nvar convertData = function (data) {\n    var res = [];\n    for (var i = 0; i < data.length; i++) {\n        var geoCoord = geoCoordMap[data[i].name];\n        if (geoCoord) {\n            res.push({\n                name: data[i].name,\n                value: geoCoord.concat(data[i].value)\n            });\n        }\n    }\n    return res;\n};\n\noption = {\n    title: {\n        text: 'echarts 和 百度地图API Demo',\n        // subtext: 'data from PM25.in',\n        // sublink: 'http://www.pm25.in',\n        left: 'center'\n    },\n    tooltip : {\n        trigger: 'item'\n    },\n    bmap: {\n        center: [104.114129, 37.550339],\n        zoom: 5,\n        roam: true,\n        mapStyle: {\n            styleJson: [{\n                'featureType': 'water',\n                'elementType': 'all',\n                'stylers': {\n                    'color': '#d1d1d1'\n                }\n            }, {\n                'featureType': 'land',\n                'elementType': 'all',\n                'stylers': {\n                    'color': '#f3f3f3'\n                }\n            }, {\n                'featureType': 'railway',\n                'elementType': 'all',\n                'stylers': {\n                    'visibility': 'off'\n                }\n            }, {\n                'featureType': 'highway',\n                'elementType': 'all',\n                'stylers': {\n                    'color': '#fdfdfd'\n                }\n            }, {\n                'featureType': 'highway',\n                'elementType': 'labels',\n                'stylers': {\n                    'visibility': 'off'\n                }\n            }, {\n                'featureType': 'arterial',\n                'elementType': 'geometry',\n                'stylers': {\n                    'color': '#fefefe'\n                }\n            }, {\n                'featureType': 'arterial',\n                'elementType': 'geometry.fill',\n                'stylers': {\n                    'color': '#fefefe'\n                }\n            }, {\n                'featureType': 'poi',\n                'elementType': 'all',\n                'stylers': {\n                    'visibility': 'off'\n                }\n            }, {\n                'featureType': 'green',\n                'elementType': 'all',\n                'stylers': {\n                    'visibility': 'off'\n                }\n            }, {\n                'featureType': 'subway',\n                'elementType': 'all',\n                'stylers': {\n                    'visibility': 'off'\n                }\n            }, {\n                'featureType': 'manmade',\n                'elementType': 'all',\n                'stylers': {\n                    'color': '#d1d1d1'\n                }\n            }, {\n                'featureType': 'local',\n                'elementType': 'all',\n                'stylers': {\n                    'color': '#d1d1d1'\n                }\n            }, {\n                'featureType': 'arterial',\n                'elementType': 'labels',\n                'stylers': {\n                    'visibility': 'off'\n                }\n            }, {\n                'featureType': 'boundary',\n                'elementType': 'all',\n                'stylers': {\n                    'color': '#fefefe'\n                }\n            }, {\n                'featureType': 'building',\n                'elementType': 'all',\n                'stylers': {\n                    'color': '#d1d1d1'\n                }\n            }, {\n                'featureType': 'label',\n                'elementType': 'labels.text.fill',\n                'stylers': {\n                    'color': '#999999'\n                }\n            }]\n        }\n    },\n    series : [\n        {\n            name: 'pm2.5',\n            type: 'scatter',\n            coordinateSystem: 'bmap',\n            data: convertData(data),\n            symbolSize: function (val) {\n                return val[2] / 10;\n            },\n            label: {\n                normal: {\n                    formatter: '{b}',\n                    position: 'right',\n                    show: false\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            itemStyle: {\n                normal: {\n                    color: 'purple'\n                }\n            }\n        },\n        {\n            name: 'Top 5',\n            type: 'effectScatter',\n            coordinateSystem: 'bmap',\n            data: convertData(data.sort(function (a, b) {\n                return b.value - a.value;\n            }).slice(0, 6)),\n            symbolSize: function (val) {\n                return val[2] / 10;\n            },\n            showEffectOn: 'render',\n            rippleEffect: {\n                brushType: 'stroke'\n            },\n            hoverAnimation: true,\n            label: {\n                normal: {\n                    formatter: '{b}',\n                    position: 'right',\n                    show: true\n                }\n            },\n            itemStyle: {\n                normal: {\n                    color: 'purple',\n                    shadowBlur: 10,\n                    shadowColor: '#333'\n                }\n            },\n            zlevel: 1\n        }\n    ]\n};\n\n\n\n\n\nmyChart.setOption(option);\n</script>\n</body>\n\n\n</html>\n```","tags":["Projects"]},{"title":"Java文本带编码读入读出","url":"/2016/11/25/Java文本带编码读入读出/","content":"\n\n很好用的java文件输入输出，不过内容比较简单，实际需要的时候还需要加上个性化设计。有空的时候可以更加模块化这个东西，主要是红来复制粘贴的...\n```Java\n public static void write(String path, String content)  \n            throws IOException {  \n        File file = new File(path);  \n        file.delete();  \n        file.createNewFile();  \n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(  \n                new FileOutputStream(file), \"UTF-8\"));  \n        writer.write(content);  \n        writer.close();  \n    }  \n  \n    public static String read(String path) throws IOException {  \n        String content = \"\";  \n        File file = new File(path);  \n        BufferedReader reader = new BufferedReader(new InputStreamReader(  \n                new FileInputStream(file), \"GBK\"));  \n        String line = null;  \n        while ((line = reader.readLine()) != null) {  \n            content += line + \"\\n\";  \n        }  \n        reader.close();  \n        content = content.replace(\"\\n\", \"\")\n        \t\t.replace(\"<&nbsp>\", \"\")\n        \t\t.replaceAll(\"<p>\", \"<p>&nbsp\");\n        //System.out.println(content);\n        return content;  \n    }\n```","tags":["Tools"]},{"title":"互农——文库模块总结","url":"/2016/11/24/互农——文库模块总结/","content":"\n近期有在忙一个Java项目，里面的文库部分，大概写完了，总结了以下几点，并附上代码。\n\n这是一个android访问，文章内容用webview（html访问）就可以了的项目。\n\n1、利用jsoup可将数据库中的文章创建成多份.html文件，注意点在于mysql中的编码格式和输出到文件时要注意输出流格式。以下是代码，主要用到jsoup包。\n\n```Java\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\n\nimport com.geowind.hunong.jpa.Article;\nimport com.geowind.hunong.jpa.ArticleDAO;\n\n/*\n//Library data\n//文库数据预览\nString _articleId; \t//ID\t\t0\nString _classification;\t//分类\t\t1\nString _title;\t\t//标题     \t\t2 \nString _list;\t\t//文章目录\t3\t如有多项，##分割\nString _summary;\t\t//简介   \t\t4\nString _keyword;\t\t//关键字\t\t5\t如有多项，##分割\nString _content;\t\t//内容\t\t6\t不同目录下文章内容用##分割，换行：<p>...</p>，空格:&nbsp\nString _imgURL;\t\t//图片链接\t7\nString _videoURL;\t//视频链接\t8\nString _other;\n*/\npublic class LibraryHTMLBuilder {\n\tString HTMLModlePath = null;//需要一个原始的模板html路径和名称\n\tString HTMLModelName = null;\n\tList<Article> articleList = null;\n\tpublic LibraryHTMLBuilder() {\n\t\tHTMLModlePath = PathUtil.Util_HTMLpath;\n\t\tarticleList = new ArticleDAO().findAll();//数据库操作，查找所有内容\n\t\tHTMLModelName = PathUtil.Util_HTMLModelName;\n\t}\n\tString[] dataMes = new String[9];\n\tpublic void SetHTMLModel(String ModelPath, String ModeName) {\n\t\tHTMLModlePath = ModelPath;\n\t\tHTMLModelName = ModeName;\n\t}\n\t// 设置文章信息，提取数据库文件\n\tpublic void CreateAllHTML() {\n\t\ttry {SetArticle();\n\t\t} catch (IOException e) {e.printStackTrace();}\n\t}\n\t// 设置每一条文章\n\tprivate void SetArticle() throws IOException {\n\n\t\t// 此处的每个都加i只是为了区别是不同的元组\n\t\tint articleNum = articleList.size();\n\t\tfor (int i = 0; i < articleNum; i++) {\n\t\t\tArticle now = articleList.get(i);\n\t\t\t/* article content format */\n\t\t\tdataMes[0] = now.getArticleId().toString();\n\t\t\tdataMes[1] = now.getClassification();\n\t\t\tdataMes[2] = now.getTitle();\n\t\t\tdataMes[3] = now.getList();\n\t\t\tdataMes[4] = now.getSummary();\n\t\t\tdataMes[5] = now.getKeyword();\n\t\t\tdataMes[6] = now.getContent();\n\t\t\tdataMes[7] = now.getImgUrl();\n\t\t\t// dataMes[8] = now.getVideoUrl();\n\t\t\t// 每设置好一个元组，便生成Html\n\t\t\tCreateHTML();\n\t\t}\n\t}\n\t/* 开始创建html */\n\tprivate void SetHtmlContent(String ModelPath, String NewPath) throws IOException {\n\t\tFile file = new File(ModelPath);\n\n\t\tDocument doc = Jsoup.parse(file, \"UTF-8\");\n\t\t// point1:set title\n\t\tElement elmt = doc.getElementById(\"title_h1\");// title\n\t\telmt.html(dataMes[2]);\n\t\t// point2:set list\n\t\telmt = doc.getElementById(\"list\");\n\t\tString[] airticlList = dataMes[3].split(\"##\");\n\n\t\tint listLen = airticlList.length;\n\t\tfor (int i = 0; i < listLen; i++) {\n\t\t\tString html = \"<li><a href=\\\"#\" + (\"info_title\" + i) + \"\\\">\" + airticlList[i] + \"</a><li>\";\n\t\t\telmt.append(html);\n\t\t}\n\t\t// point3: set description 简介\n\t\telmt = doc.getElementById(\"summary\");\n\t\telmt.html(dataMes[4]);\n\t\t// point4:set articles\n\t\telmt = doc.getElementById(\"article_div\");\n\t\tString[] articles = dataMes[6].split(\"##\");\n\t\tint minLen = Math.min(airticlList.length, articles.length);\n\t\t// int articleLen = articles.length;//listLen和articlelen应该是相等的\n\t\tfor (int i = 0; i < minLen; i++) {\n\t\t\tString html = \"<div><h1 id=\\\"info_title\" + i + \"\\\">\" + airticlList[i] + \"</h1>\" + articles[i] + \"</div>\";\n\t\t\telmt.append(html);\n\t\t}\n\t\t// set pictures\n\t\tString imgTag = \"<img src=\"+ PathUtil.Lib_PictureURL + dataMes[7] + \"\\\" width=\\\"100%\\\" height=\\\"100%\\\">\";\n\t\tSystem.out.println(imgTag);\n\t\telmt = doc.getElementById(\"header_right\");\n\t\telmt.append(imgTag);\n\t\t// set finished\n\t\tfile = new File(NewPath);\n\t\tif (file.exists())\n\t\t\tfile.delete();\n\t\tFileOutputStream fos = new FileOutputStream(NewPath, true);\n\t\tOutputStreamWriter osw = new OutputStreamWriter(fos, \"UTF-8\");\n\n\t\tosw.write(doc.html());\n\t\tosw.flush();\n\t\tosw.close();\n\n\t\t// fos.write(doc.html().getBytes());这种会乱码\n\t\t// fos.close();\n\n\t}\n\n\tprivate void CreateHTML() throws IOException {\n\t\t// step1 build path 制作路径\n\t\tString ModelPath = HTMLModlePath + \"/\" + HTMLModelName; // 模板文件完整路径\n\t\tString NewPath = HTMLModlePath + \"/\" + dataMes[0] + \".html\";// 新建文件完整路径\n\n\t\t// System.out.println(ModelPath);\n\t\t// step2 set html and setp3 write html 解析html并设置新值，写出html\n\t\tSetHtmlContent(ModelPath, NewPath);\n\t}\n\n\t// public static void main(String[] args) {\n\t// LibraryHTMLBuilder lhb = new LibraryHTMLBuilder();\n\t// lhb.CreateAllHTML();\n\t// }\n\n}\n```\n2、自己写的模糊查询，很普遍了，由于中文的关系，数据库连接时的字符串需要注意一下。\n\n```Java\n//db.properties\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://127.0.0.1:3306/databases?characterEncoding=utf-8\nusername=xxx\npassword=xxx\n```\n```Java\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport javax.sql.DataSource;\n\nimport org.apache.commons.dbcp2.BasicDataSourceFactory;\nimport org.apache.logging.log4j.LogManager;\n//仅连接部分，下面还有一些\npublic class DBHelper {\n\n\tprivate static DataSource dataSource;\n\n\tstatic {\n\t\ttry { // Class.forName(DRIVER_CLASS_NAME);\n\t\t\tProperties props = new Properties();\n\t\t\tInputStream in = DBHelper.class.getClassLoader()\n\t\t\t\t\t.getResourceAsStream(\"db.properties\");\n\t\t\tprops.load(in);\n\n\t\t\t// 使用连接池技术，数据源DBCP\n\t\t\tdataSource = BasicDataSourceFactory.createDataSource(props);\n\t\t\tLogManager.getLogger().debug(\"加载数据库属性元素构建数据源成功\");\n\t\t} catch (Exception e) {\n\t\t\tLogManager.getLogger().error(\"加载数据库属性元素构建数据源失败\", e);\n\t\t}\n\t}\n\n\t/**\n\t * 连接数据库\n\t * \n\t * @return\n\t */\n\tpublic static Connection getConn() {\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tcon = dataSource.getConnection();\n\t\t\tLogManager.getLogger().debug(\"数据库连接成功\");\n\t\t} catch (Exception e) {\n\t\t\tLogManager.getLogger().error(\"数据库连接失败\", e);\n\t\t}\n\t\treturn con;\n\t}\n}\n```\n\n```Java\nimport static com.geowind.hunong.util.PathUtil.ServerIP;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.geowind.hunong.entity.ArticleSim;\n\npublic class DBHelperSim {\n\n\t// other\n\tprivate static List<ArticleSim> sqlExecute(String sql) {\n\t\tList<ArticleSim> res = new ArrayList<>();\n\n\t\ttry {\n\t\t\tConnection conn = DBHelper.getConn();\n\t\t\tStatement stmt = conn.createStatement(); // 创建Statement对象\n\t\t\t// System.out.println(\"成功连接到数据库！\");\n\t\t\t// System.out.println(sql);\n\t\t\tResultSet rs = stmt.executeQuery(sql);// 创建数据对象\n\t\t\twhile (rs.next()) {\n\n\t\t\t\tString id = rs.getString(\"articleId\");\n\t\t\t\t// System.out.println(id_list.size());\n\t\t\t\tString title = rs.getString(\"title\");\n\t\t\t\tString url = \"http://\" + ServerIP + \":8080/MutualAgriculture/LibraryHTML/\" + id + \".html\";\n\t\t\t\tString summary = rs.getString(\"summary\");\n\t\t\t\tres.add(new ArticleSim(id, title, summary, url));\n\t\t\t}\n\t\t\trs.close();\n\t\t\tstmt.close();\n\t\t\tconn.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static List<ArticleSim> GetArticleSimUseSql(String sql) {\n\n\t\treturn sqlExecute(sql);\n\t}\n\t// public static void main(String[] args) {\n\t// List<String> list = GetIdBykeyword(\"我是\",\"select * from article where\n\t// keyword like '\" + \"%我是关键字\" + \"'\");\n\t// System.out.println(list.get(0));\n\t// }\n\n}\n```\n3、最后应该是Servlet和一些工具类\n\n```Java\nimport static com.geowind.hunong.util.PathUtil.*;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.geowind.hunong.entity.ArticleSim;\nimport com.geowind.hunong.util.DBHelperSim;\nimport com.geowind.hunong.util.LibraryKeywordSearch;\nimport com.google.gson.Gson;\n\n/**\n * Servlet implementation class LibraryServlet\n */\npublic class LibraryServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n\t\trequest.setCharacterEncoding(\"utf-8\");\n\t\tresponse.setCharacterEncoding(\"utf-8\");\n\t\tString method = null;\n\t\ttry{\n\t\t\tmethod = request.getParameter(\"method\");\n\t\t}catch (NullPointerException e) {\n\t\t\treturn ;\n\t\t}\n\t\tif (method.equals(\"serchLib\")) {\n\t\t\tSearchMethod(request, response);\n\t\t} else if (method.equals(\"getArticles\")) {\n\t\t\tGetArticlesMethod(request, response);\n\t\t}else{\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tdoGet(request, response);\n\t}\n\n\tprivate void SearchMethod(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\tString keyword = request.getParameter(\"keyword\");\n\t\tSystem.out.println(\"library serlvet op=\" + keyword);\n\t\t// String keyword = request.getParameter(\"keyword\");\n\t\tList<ArticleSim> ArticleMeg = LibraryKeywordSearch.GetMatchArticlesURL(keyword);\n\t\tfor (int i = 0; i < ArticleMeg.size(); i++) {\n\t\t\tArticleSim now = ArticleMeg.get(i);\n\t\t\tnow.url = \"http://\" + ServerIP + \":8080/MutualAgriculture/LibraryHTML/\" + now.id + \".html\";\n\t\t}\n\t\t// System.out.println(\"IP=\"+ServerIP);\n\t\tPrintWriter out = response.getWriter();\n\t\tGson gson = new Gson();\n\t\tString msg = gson.toJson(ArticleMeg);\n\n\t\tout.print(msg);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\t//辅助搜索，由于在分页搜索按条件搜索时可能会出现或不足的情况，需要向后延续。\n\t//记录当前向后延续到了哪里,并从那里继续往下查找\n\tprivate int [] beginOfSearch = new int[9];\n\tprivate boolean isFirstGet = true;\n\tprivate void GetArticlesMethod(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tString category = request.getParameter(\"category\");\n\t\tString nowPage = request.getParameter(\"nowPage\");\n\t\t\n\t\t// 10001 10010\n\t\tint type = Integer.parseInt(category); //需要查的文章类别\n\t\tint pagN = Integer.parseInt(nowPage);  //当前分页数目\n\t\t\n\t\t//如果当前分页是第一页（即第0页),对当前类别给定初始值。\n\t\tif(isFirstGet) {\n\t\t\tfor(int i=0;i<9;i++) beginOfSearch[i] = ArticleBeginId;\n\t\t\tisFirstGet = false;\n\t\t}\n\t\tif(pagN == TabBegin){\n\t\t\tbeginOfSearch[type] = ArticleBeginId;\n\t\t}\n\t\t\n\t\tList<ArticleSim> res = new ArrayList<>();\n\t\t\n\t\twhile(res.size()<APageOfTable_N && beginOfSearch[type]<=ArticleEndId){\n\t\t\t\n\t\t\tint begin_page = beginOfSearch[type];\n\t\t\tint end_page = begin_page+(APageOfTable_N-res.size()) - 1;\n\t\t\tbeginOfSearch[type] = end_page + 1;\n\t\t\t\n\t\t\tString sql = \"select * from article \";\n\t\t\tif (category.equals(\"0\")) {\n\t\t\t\tsql += \"where articleId between \" + begin_page + \" and \" + end_page;\n\t\t\t} else {\n\t\t\t\tsql += \"where classification like '%\" + category + \"%' and articleId between \" + begin_page + \" and \"\n\t\t\t\t\t\t+ end_page;\n\t\t\t}\n\t\t\t\n\t\t\tres.addAll(DBHelperSim.GetArticleSimUseSql(sql));\n\t\t}\n\t\t\n\t\t\n\t\tPrintWriter out = response.getWriter();\n\t\tGson gson = new Gson();\n\t\tString msg = gson.toJson(res);\n\n\t\tout.print(msg);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n}\n```\n```Java\npublic class PathUtil {\n\tpublic static String Util_HTMLpath = \"LibraryHTML\";\n\tpublic static String Util_HTMLModelName = \"library.html\";\n\tpublic static String Lib_PictureURL = \"/images/\";\n\tpublic final static String ServerIP = \"115.159.125.122\";\n\t\n\tpublic static int ArticleNumber = 0;//文章总条数\n\tpublic static int ArticleBeginId = 0; //文库开始编号\n\tpublic static int ArticleEndId = 0; //文库开始编号\n\tpublic final static int TabBegin = 0;//分页从第几页开始\n\tpublic final static int APageOfTable_N = 10;//一页显示10条目录\n\t\n}\n```\n补充一点，如果在java web想要在项目刚启动时处理某些东西，可以在xml中如下配置，并写一个initServlet。\n```Sql\n<servlet>\n\t<servlet-name>InitServlet</servlet-name>\n\t<servlet-class>com.geowind.hunong.servlet.InitServlet</servlet-class>\n\t初始化变量xx为haha\n        <init-param>\n\t\t<param-name>xx</param-name>\n\t\t<param-value>haha</param-value>\n\t</init-param>\n        启动优先级 0 最大\n\t<load-on-startup>0</load-on-startup>\n</servlet>\n```\n这次收获还不小，只是发现自己不太喜欢做这种繁琐的事。","tags":["Projects"]},{"title":"本科生涯的ACM历程总结——记香港区域赛","url":"/2016/11/14/本科生涯的ACM历程总结——香港区域赛/","content":"自参加完CCPC杭州赛区和ICPC香港赛区已经过去一周的时间了，现在已经大三，差不多也到了退役的时间。ACM这个东西从大一上学期开始到现在，匆匆忙忙过了2年了。昨天，自己实验室的朋友们分别打完青岛区域赛和北京区域赛后双双打铁，最近这几场比赛也算作是我们14级acmer的退幕赛把，虽然都留有遗憾，但想必收获必定不小。\n\n大概总结一下香港这趟旅程和ICPC，此次是我第二次来到香港了，第一次是在高考完的那个暑假，考试考得不好，当做来香港散散心。再次到香港，感觉并没有什么新鲜之处：从学校到深圳，然后从深圳过关，一切都比较顺利。凭借了地图导航和自己优美的普通话以及蹩脚的英语，最后算是达到了目的地：香港中文大学（CUHK）。首先我们并没有找到大门在哪里，其次呢这种同学之间用粤语夹杂英语的交流方式还是和内地很不同的。当然这边的英语水平挺不错的。\n\n接下来是签到和开幕式，依旧很顺利，注册的时候留下下面这张神照：\n<div align=center>\n<img src=\"/images/2016_HK_1.jpg\" >\n</div>\n比赛场地是机房，很出人意料，竟然不是气势恢宏的体育场。至于操作系统和编译环境，自然是ubuntu标准和g++/gcc。这次有一点我们失策的是：来之前忘记仔细查看标准了，导致全局在用记事本编程然后用shell框编译，说不定这也是我们这次打铁的一个原因。\n\n第一天结束，回到旅馆稍作休息后在街上逛了一会儿也就睡觉了。\n随之是第二天的比赛，似乎结果并不出人意料，但是和我们去之前想得并不一样：机会还是有的！只是我们没有把握住把。比赛时想得思路和最后讲解的题解思路如出一辙，但就是没有过AC那一关。我们想罢是精度、还是细节上的问题，这也给我们留下了一些疑惑。在回来的这一周，回过头来思考这些问题，解法确实就是当初想的那样。比赛过程中的一些小食和场地（那么多气球的队可惜不是我们）\n<div align=center>\n<img src=\"/images/2016_HK_2.jpg\">\n<img src=\"/images/2016_HK_3.jpg\">\n</div>\n\n晚餐时间很不错，有海鲜餐还有标准的西餐服务员什么的，虽然看着大佬们颁奖很是羡慕与不甘，但想想终究是自己造成的结果。这份被称为 a great dinner的晚饭感觉像是被喝橙汁喝饱的。\n\n<div align=center>\n<img src=\"/images/2016_HK_4.jpg\">\n<img src=\"/images/2016_HK_5.jpg\">\n</div>\n\n吃完晚饭后也就会宾馆休息了，第三天算是简单逛了一下香港。当然咯，在太平山的时候找了两个国外的型男拍了合照，还是挺佩服自己的 Can you take a photo with me? 的完美发音的。\n\n总体行程就是这样了，这也算是我大学本科生涯最后一次参加ACM比赛了吧。昨天看到竞赛群里有些14级的同学因为这次的遗憾还想再搞一年，我也犹豫过，真的希望他们如果继续，下一年能拿到好的成绩。不过对于我来说，历史总是惊人的相似这句话被我认为能够很好地概括这件事。在大的环境没有改变和自身不会发生颠覆性的变化之前，结果总是出人意料的相似吗。若是我们在其位时能够全心全意投入，那么这两年也不会以这样的结果告终。\n这次的结束，让我以前想要读研的决心更加明朗了，一些无奈和不甘终究会沉淀下来，愿能够完成未尽之心愿，同样也祝福大家顺利。\n\n少说话都做事。","tags":["ACM&OJ"]},{"title":"Java的简单大数加法(A + B Problem II)及java环境的配置","url":"/2015/08/05/Java的简单大数加法(A + B Problem II)及java环境的配置/","content":"\n最近讲到高精度专题了，于是果断想到了用Java，虽然以前没接触过Java，还是被它的方便性吸引了，下个JDK和eclipsean安装完再配置一下Java环境就可以了，下面稍微提一下环境配置吧（我搞了好久，不过网上好多教程）\n\n桌面右键我的电脑（计算机）-->属性-->高级系统设置-->（高级中的）环境变量:\n\n在系统变量里面最后要出现这三个变量（有就改一下变量值，没有就新建）\n```\n变量名\n变量值\nJAVA_HOME \nJava的安装路径，要求安装JDK的时候的路径（我的是G :\\ JAVA \\JDK）\n\nPATH\n%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\nCLASSPATH\n.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n （直接复制就好了）\n```\n接下来看一道题\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1002\n```Java\nimport java.io.*;    \nimport java.math.*;    \nimport java.util.*;    \nimport java.text.*;   \n  \npublic class Main{  \n    public static void main(String[] args)  \n    {  \n        Scanner cin = new Scanner (new BufferedInputStream(System.in));  \n        int times=1;  \n        int T;  \n        T=cin.nextInt();  \n        while(T!=0)  \n        {  \n            BigInteger a;  \n            BigInteger b;  \n            a=cin.nextBigInteger();  \n            b=cin.nextBigInteger();  \n            System.out.println(\"Case \"+ (times++)+\":\");  \n            System.out.println(a + \" + \" + b + \" = \" + a.add(b));  \n            if(T!=1) System.out.println(\"\");  \n            T--;  \n        }  \n          \n    }  \n}  \n```\n\n```Java\npublic class Main //这里各个OJ默认的不同,此处只能用Main  \n```","tags":["ACM&OJ"]},{"title":"C++STL二分查找函数集及补充","url":"/2015/08/04/C++STL二分查找函数集及补充/","content":"\nC++中还是有许多我未了解或者不常用的函数，比如今天写下的一些二分函数，还是挺有用的，不仅仅可以减少代码量，而且能够增加时间的利用率。（目前我只学了简单的数组查找，有待补充）\n\n大概有以下几个STL中的二分查找函数：\n\n```C++\nbinary_search(a,a+n,key)    //返回是否存在值bool型的  \nlower_bound(a,a+n,key)      //下面两个都是指针型的  \nupper_bound(a,a+n,key)  \n/*升序排列的容器： \nlower_bound( const key_type &key ): 返回一个迭代器，指向键值>= key的第一个元素。 \nupper_bound( const key_type &key ): 返回一个迭代器，指向键值>key的第一个元素。 \n//降序排列的容器： \nlower_bound( const key_type &key ): 返回一个迭代器，指向键值<= key的第一个元素。 \nupper_bound( const key_type &key ):返回一个迭代器，指向键值<key的第一个元素。 \n*/  \n```\n\n以下介绍一下手工写的二分函数，也可以改成系STL的函数：\n一、判断是否存在key值：\n\n```C++\nbool search(int A[], int n, int target)  \n{  \n    int low = 0, high = n-1;  \n    while(low <= high)  \n    {  \n        int mid = low+((high-low)>>1);  \n        if(A[mid] == target)  \n            return true;  \n        else if(A[mid] < target)  \n            low = mid+1;  \n        else  \n            high = mid-1;  \n    }  \n    return false;  \n}  \n```\n二、存在相同key值时查找最先出现的位置：\n\n```C++\n//此函数返回的是第几个元素，非数组下标  \nint lower_search(int A[], int n, int target)  \n{  \n    int low = 0, high = n-1;  \n    while(low <= high)  \n    {  \n        int mid = low+((high-low)>>1);  \n        if(A[mid] == target)  \n        {  \n            if(mid > 0 && A[mid-1] == target)  \n                high = mid-1;  \n            else  \n                return mid;  \n        }  \n        else if(A[mid] < target)  \n            low = mid+1;  \n        else  \n            high = mid-1;  \n    }  \n    return -(low+1);  \n}  \n```\n三、存在相同元素的时候，返回最后出现的位置：\n```C++\n[cpp] view plain copy\n//此函数返回的是第几个元素，非数组下标  \nint upper_search(int A[], int n, int target)  \n{  \n    int low = 0, high = n-1;  \n    while(low <= high)  \n    {  \n        int mid = low+((high-low)>>1);  \n        if(A[mid] == target)  \n        {  \n            if(mid < n-1 && A[mid+1] == target)  \n                low = mid+1;  \n            else  \n                return mid;  \n        }  \n        else if(A[mid] < target)  \n            low = mid+1;  \n        else  \n            high = mid-1;  \n    }  \n    return -(low+1);  \n}  \n```\n三、存在多个key值时，返回位置差：\n```C++\nint equal_search(int A[], int n, int target){  \n    int tmp = upper_search(A, n, target)-lower_search(A, n, target);  \n    return tmp;  \n}  \n```","tags":["Tools"]},{"title":"一些DP经典问题：HDU(hdoj) 2126，1176，2546，1159","url":"/2015/07/27/一些DP经典问题：HDU(hdoj) 2126，1176，2546，1159/","content":"\n今天开始做DP（动态规划）的题了，按照刘汝佳大叔的话来说，动态规划不是严格意义上的算法，而是一种解决问题的策略。果然，这个叫策略的东西真是变化多样，不过呢还是有一些规律可以寻找的。像网上有许多大牛们总结的背包问题，还是挺不错的。下面贴几道今天刚做的背包转换的问题，还有个入门级的的lcs题。\n\n   第一题：http://acm.hdu.edu.cn/showproblem.php?pid=2126\n\n大意：大家出去旅游，想买纪念品，但是带的钱有限，问问带的钱最多能在N种商品中买几种。给出每件商品的价格，求出有几种方案买到最多的纪念品种类。\n\n虽然没说买几件，但想一下：他是要求种类，不是总题的数量，所以自然想到了0/1背包，但是要求记录种类，所以我们可以多创建个数组Kinds，再每次dp的时候对kinds数组也进行滚动操作，以下给出内存优化0/1背包写法\n\n```C++\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n  \nusing namespace std;  \n  \nint dp[500+10],kinds[500+10];//kinds用来记录种类数  \nint w[500+10];  \n  \nint main()  \n{  \n    int T;  \n    scanf(\"%d\",&T);  \n    while(T--)  \n    {  \n        int n,k;  \n        scanf(\"%d%d\",&n,&k);  \n        for(int i=0;i<n;i++)  \n            scanf(\"%d\",&w[i]);  \n        memset(dp,0,sizeof(dp));  \n        for(int i=0;i<=k+1;i++)  \n            kinds[i]=1;        //初始值记1，不然结果会全为0的  \n        for(int i=0;i<n;i++)  \n        {  \n            for(int j=k;j>=w[i];j--)  \n            {  \n                if(dp[j]==dp[j-w[i]]+1)             //这里是0/1背包的经典决策方式  \n                    kinds[j]=kinds[j-w[i]]+kinds[j];  \n                else if(dp[j]<dp[j-w[i]]+1)  \n                {  \n                    dp[j]=dp[j-w[i]]+1;             //找到更优解则更新数组  \n                    kinds[j]=kinds[j-w[i]];  \n                }  \n            }  \n        }  \n        if(dp[k])  \n            printf(\"You have %d selection(s) to buy with %d kind(s) of souvenirs.\\n\",kinds[k],dp[k]);  \n        else  \n            printf(\"Sorry, you can't buy anything.\\n\");  \n    }  \n    return 0;  \n}  \n```\n第二题 http://acm.hdu.edu.cn/showproblem.php?pid=1176\n\n刚开始做成了min的0/1背包，果断错了。。。感觉到了不懂脑筋的后果。\n\n这题大概这么解：总之最后拿5块钱来买最贵的菜maxp元，剩下的m-5块钱在剩下的菜中尽可能地多买，最好用完，然后用总钱数减去5元，再减最贵的就是（m-5-maxp)最少价格了,下面给出代码\n\n```C++\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \nusing namespace std;  \nint dp[1000+10];  \nint w[1000+10];  \nint main()  \n{  \n    int n;  \n    while(~scanf(\"%d\",&n)&&n)  \n    {  \n        memset(dp,0,sizeof(dp));  \n        memset(w,0,sizeof(w));  \n        for(int i=0;i<n;i++)  \n            scanf(\"%d\",&w[i]);  \n        sort(w,w+n);  \n        int maxf=w[n-1],tn=n-1;  \n        int m;  \n        scanf(\"%d\",&m);  \n        if(m<5) printf(\"%d\\n\",m);  \n        else  \n        {  \n            int tm=m-5;  \n            for(int i=0;i<tn;i++)  \n                for(int j=tm;j>=w[i];j--)  \n                    dp[j]=max(dp[j],dp[j-w[i]]+w[i]);  \n            printf(\"%d\\n\",m-dp[tm]-maxf);  \n        }  \n    }  \n    return 0;  \n}  \n\n```\n下面这题，类似经典的塔类问题：http://acm.hdu.edu.cn/showproblem.php?pid=2546\n采用自底向上的做法，用dp[ i ][ j ]来表示第i个坐标第j秒下落的馅饼数。\n\n```C++\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <cmath>  \n#define MAXN 100000+10  \nusing namespace std;  \n  \nint dp[15][MAXN];  \nint t=0;  \nint main()  \n{  \n    int n;  \n    while(~scanf(\"%d\",&n)&&n){  \n        t=0;  \n        memset(dp,0,sizeof(dp));  \n        for(int i=0;i<n;i++){  \n            int x,tt;  \n            scanf(\"%d%d\",&x,&tt);  \n            dp[x+1][tt]++;  \n            t=max(tt,t);  \n        }  \n        for(int i=t-1;i>=0;i--)  \n            for(int j=1;j<=11;j++)  \n                dp[j][i]+=max(dp[j][i+1],max(dp[j+1][i+1],dp[j-1][i+1]));  \n        printf(\"%d\\n\",dp[6][0]);  \n    }  \n    return 0;  \n}  \n\n```\n最后一题是最长公共子序列问题，我还在研究怎么输出来这个最长串：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1159\n```C++\n#include <iostream>  \n#include <cstring>  \n#include <cstdio>  \nusing namespace std;  \n  \nchar a[1000],b[1000];  \nint dp[1000][1000];  \n  \nint dps(int len1,int len2,char a[],char b[]){  \n    memset(dp,0,sizeof(dp));  \n    for(int i=1;i<=len1;i++){  \n        for(int j=1;j<=len2;j++){  \n            if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]+1;  \n            else{  \n                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);  \n            }  \n        }  \n    }  \n    return dp[len1][len2];  \n}  \n  \n  \nint main()  \n{  \n    while(~scanf(\"%s%s\",a,b)&&strlen(a)){  \n        int len1=strlen(a);  \n        int len2=strlen(b);  \n        printf(\"%d\\n\",dps(len1,len2,a,b));  \n    }  \n    return 0;  \n}  \n```\n继续学习DP ！","tags":["ACM&OJ"]},{"title":"C++利用stl::sort对结构体数组中的字符串成员排序","url":"/2015/07/26/C++利用stl::sort对结构体数组中的字符串成员排序/","content":"\n之前发过的帖中，有讲到过对结构体字符串进行排序的，除了手写之外，便想到用C/C++中的qsort来对结构体数组中的字符串进行排序。但是推广到sort中时，想了好久也没想明白，看看网上这样的帖也比较少，其实还是很好理解的，主要是std::sort的cmp函数要求是bool的返回值，随意抓住这点就可以。\n\n问题大概是这样：\n\n```C++\n#include <iostream>  \n#include <cstdio>  \n#define MAXN 50  \nusing namespace std;  \n  \nstruct tmpToStruct{  \n    char ArraryString[MAXN];  \n};  \n  \ntmpToStruct step[5+1];  \n  \nint main()  \n{  \n    for(int i=0;i<5;i++)  \n        scanf(\"%s\",step[i].ArraryString);  \n    return 0;  \n}  \n```\n\n对step里的ArraryString按照字符串的字典序进行排序，下面给出sort排序的方法：\n```C++\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n#define MAXN 50  \nusing namespace std;  \n  \nstruct tmpToStruct{  \n    char arrStr[MAXN];  \n};  \n  \ntmpToStruct step[5+1];  \n  \nbool upCmp(const tmpToStruct &tmp1,const tmpToStruct &tmp2){  \n         return strcmp(tmp1.arrStr,tmp2.arrStr)<0 ? true : false;  \n}  \n  \nbool downCmp(const tmpToStruct &tmp1,const tmpToStruct &tmp2){  \n         return strcmp(tmp1.arrStr,tmp2.arrStr)>0 ? true : false;  \n}  \nint main()  \n{  \n    puts(\"before the sort:\");  \n    for(int i=0;i<5;i++)  \n        scanf(\"%s\",step[i].arrStr);  \n    cout << endl;  \n  \n    sort(step,step+5,upCmp);  \n    puts(\"after the up sort:\");  \n    for(int i=0;i<5;i++)  \n        puts(step[i].arrStr);  \n    cout << endl;  \n  \n    puts(\"after the down sort:\");  \n    sort(step,step+5,downCmp);  \n    for(int i=0;i<5;i++)  \n        puts(step[i].arrStr);  \n    cout << endl;  \n    return 0;  \n}  \n```\n对比下qsort的排序，还是很简短的。","tags":["Tools"]},{"title":"再谈字典树：HDOJ 1671 Phone List（内存释放）","url":"/2015/07/24/再谈字典树：HDOJ 1671 Phone List（内存释放）/","content":"\n前两天刚发了篇博客，讲的是两道简单的字典树，今天无意间看到了这道题，我觉得有必要再来扩充一下我的字典树知识：合理分配动态内存。记得上C++课的时候，老师讲过，用new创建的指针，程序结束后最好都用delete来删除动态内存，不然会造成内存泄露。然而以前做的题虽然内存开的很大，也没在意。看了今天这道，自己也反思了下，像很多网友说的，不要为了AC而AC，虽然说的很那啥，但这确实是值得我思考的。\n\n看一下题吧：\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1671\n\n题意：给你一组电话，如果里面有一些短的号码（设整个号码为i）和长一点的号码的前i个数字相同，那么电话机会自动拨打那个短号码，所以你就不能往下按了。就是你不能拨打那个长号码了。如果有这种短号码，即不能拨打某个号码，输出NO，否则输出YES；\n```C++\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \nusing namespace std;  \n  \nstruct Trie{  \n    Trie *next[11];  \n    bool boom;  \n    Trie(){  \n        for(int i=0;i<11;i++)  \n            next[i]=NULL;  \n        boom=true;  \n    }  \n};  \n  \nbool flag=true;  \n  \nvoid buildAndSearch(char s[],Trie *root){  \n    Trie *now=root;  \n    int len=strlen(s);  \n    for(int i=0;i<len;i++){  \n        if(now->next[s[i]-'0']==NULL)  \n            now->next[s[i]-'0']=new Trie;  \n        else{  \n            if((now->next[s[i]-'0'])->boom==false){  \n                flag=false; break;  \n            }  \n        }  \n        now=now->next[s[i]-'0'];  \n    }  \n    now->boom=false;  \n  \n    for(int i=0;i<11;i++){  \n        if(now->next[i]!=NULL){  \n            flag=false;return;  \n        }  \n    }  \n}  \nvoid freeDom(Trie *now){  \n    for(int i=0;i<11;i++){  \n        if(now->next[i]!=NULL) freeDom(now->next[i]);  \n    }  \n    delete now;  \n}  \nint main()  \n{  \n    int T;  \n    scanf(\"%d\",&T);//scanf(\"\\n\");  \n    while(T--){  \n        flag=true;  \n        Trie *root=new Trie;  \n        int N;  \n        scanf(\"%d\",&N);scanf(\"\\n\");  \n        char pn[11];  \n        while(N--){  \n            scanf(\"%s\",pn);  \n            buildAndSearch(pn,root);  \n        }  \n        if(flag) printf(\"YES\\n\");  \n        else printf(\"NO\\n\");  \n        freeDom(root);  \n    }  \n    return 0;  \n}  \n```\n注意911(先)   91125426(后) 和 91125426(先)   911(后)，输入循序不同要都考虑进去。当然，若是使用那种建树与查询分开的做法，好像是不用讨论的，具体我没试过，最后记得将每次的动态内存删除。","tags":["ACM&OJ"]},{"title":"字典树例题介绍：ZOJ 1109,HDOJ 1075","url":"/2015/07/24/字典树例题介绍：ZOJ 1109,HDOJ 1075/","content":"\n关于字典树，相信还是比较好理解的吧，就是将一次输入中的一些单词，字符串建立成字典。将这些字符每一层存放一个字符，顺序往下查找，在该个字符串（找完该字符串的最后一个字符，即最后一个节点）末尾设置一个节点（一般是存放的东西，比如要翻译过来的单词啊什么的）。\n\n下面来分享两道典型的字典树题：\n\n1.ZOJ 1109 Language of FatMouse：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1109\n\n大概题意:FatMouse只会说鼠语，但是为了迎接WTO的热潮，它想学好英语，所以就搞了个类似小抄的东西。输入英语语言和鼠语，要求我们将鼠语言翻译英语输出。\n\n这是单词的翻译，属于简单的字典树。只要将鼠语见成字典树，对应的英语单词作为节点放在鼠语结束的末尾，每次翻译是查找字典树即可。\n\n```C\n#include <iostream>  \n#include <cstring>  \n#include <cstdio>  \n#include <string>  \nusing namespace std;  \n  \nchar fwords[11];  \nstruct Trie{  \n    Trie *next[26];     //建树，每一层都有26个小写的英文单词（管它用不用呢，万一要全用），如果加入大写和数字，那就要开的更大了  \n    char eword[11];     //用来储存英语（要存在节点出的，同样，管他用不用呢。  \n  \n    Trie(){             //树的初始化  \n        for(int i=0;i<26;i++)  \n            next[i]=NULL;  \n        eword[0]='\\0';  \n    }  \n};  \nTrie root;                          //这里是树根，从此开始往下建树  \nvoid build(char ew[],char d[]){     //d是鼠语  \n    Trie *now=&root;                //每次建树都要从树根开始，看看初始鼠语字符是否存在  \n    int len=strlen(d);  \n    for(int i=0;i<len;i++){  \n        if(now->next[d[i]-'a']==NULL)   //如果没有，那就新往下建一个  \n            now->next[d[i]-'a']=new Trie;  \n        now=now->next[d[i]-'a'];        //有那就顺着这个节点往下摸  \n    }  \n    strcpy(now->eword,ew);  \n}  \nchar *TrieSearch(char str[]){  \n    Trie *p=&root;  \n    int len=strlen(str);  \n    int i;  \n    for(i=0;i<len&&p->next[str[i]-'a']!=NULL;i++)  \n        p=p->next[str[i]-'a'];  \n    if(i==len&&strlen(p->eword)!=0)  \n        return p->eword;  \n    return NULL;  \n  \n}  \nint main()  \n{  \n    char re[11],dic[11];  \n    char line[30];  \n    while(gets(line)){  \n        if(strlen(line) == 0)break;  \n        sscanf(line,\"%s%s\",re,dic);  \n        build(re,dic);  \n    }  \n    while(gets(line)){  \n        char *p=TrieSearch(line);  \n        if(p) printf(\"%s\\n\",p);  \n        else printf(\"eh\\n\");  \n    }  \n    return 0;  \n}  \n```\n\n接下来是个稍微变化了一下的字典树题目：\nDHOJ 1075hdoj What Are You Talking About：http://acm.hdu.edu.cn/showproblem.php?pid=1075\n\n题意：同样也是要翻译，但是这次输入有其他的各种符号，但是不用管它，最后的时候处理就好了，给出代码：\n```C\n//Trie  \n#include <iostream>  \n#include <cstring>  \n#include <cstdio>  \n#include <string>  \n#include <cctype>  \n  \nchar tmp[3000+10];  //后续输入  \n//树的结构体  \nstruct Trie{  \n    char ewards[11];  \n    Trie *next[26];  \n    Trie(){  \n        for(int i=0;i<26;i++)  \n            next[i]=NULL;  \n        ewards[0]='\\0';  \n    }  \n};  \nTrie root;          //建立字典树树根  \n//函数功能：建树并保存单词（即在单词结束时保存节点）  \nvoid build(char e[],char mar[]){  \n    Trie *now=&root;            //从树顶端开始建立  \n    int len=strlen(mar);  \n    for(int i=0;i<len;i++){     //mar是字典，直到将其全部非'\\0'字符历遍  \n        if(now->next[mar[i]-'a']==NULL)  \n            now->next[mar[i]-'a']=new Trie;//如果该字符未被保存过，那么建立新的节点  \n        now=now->next[mar[i]-'a'];  \n    }  \n    strcpy(now->ewards,e);  \n}  \n  \nchar *TrieSearch(char s[]){  \n    Trie *p =&root;  \n    int i;          // 下边还会用到  \n    for(i=0;s[i]!='\\0'&&p->next[s[i]-'a']!=NULL;i++)  \n        p=p->next[s[i]-'a'];            //符合要求那么就继续向下  \n    if(s[i]=='\\0'&&strlen(p->ewards)!=0)//s被历遍，且最后一个树点有节点标记（此处为有单词  \n        return p->ewards;  \n    return NULL;  \n}  \n  \nusing namespace std;  \n  \nint main()  \n{  \n    char ear[11],mar[11];  \n    scanf(\"%s\",ear);  \n    while(scanf(\"%s\",ear)&&ear[0]!='E'){  \n        scanf(\"%s\",mar);  \n        build(ear,mar);  \n    }  \n    scanf(\"%s\",mar);scanf(\"\\n\");    //输入START，记得吞'\\n'  \n    memset(tmp,'\\0',sizeof(tmp));  \n    while(gets(tmp)!=NULL&&tmp[0]!='E'){  \n        int len=strlen(tmp);  \n        tmp[len]=' ';len++;  \n        char tp[3000+10];  \n        for(int i=0,k=0;i<len;i++){  \n            if(tmp[i]>='a'||tmp[i]<='z'){  \n                tp[k]='\\0';  \n                char *temp=TrieSearch(tp);  \n                if(temp) printf(\"%s\",temp);  \n                else printf(\"%s\",tp);  \n                k=0;                    //从新开始保存单词或者结束  \n                if(i!=len-1) printf(\"%c\",tmp[i]);  \n            }  \n            else  \n                tp[k++]=tmp[i];  \n        }  \n        printf(\"\\n\");  \n    }  \n    return 0;  \n}  \n```\n\n不难发现，字典树对于内存上的消耗还是很大的，下面给出第一题的另一种解法，研究qsort的结构体字符串排序想了好久，再利用二分，时间上就满足了。但是这种方法有些题目还是有些不适用的。我也没想清楚。\n\n```C\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n#define MAXN 100000+10  \nusing namespace std;  \n  \nstruct words{  \n    char ewords[11];  \n    char ftword[11];  \n}arr[MAXN];  \n  \nint cmp(const void *a,const void *b){  \n    struct words *pa = (struct words *)a;  \n    struct words *pb = (struct words *)b;  \n    return strcmp(pa->ftword,pb->ftword);  \n}  \nchar * dsearch(char id[],int low,int high){ // 排序后进行二分查找，快速定位下来  \n    while(low<=high){  \n        int mid=(low+high)>>1;  \n        //cout << \"str1=\"<< id <<\" str2=\"<<arr[mid].ftword<<endl;  \n        if(!strcmp(id,arr[mid].ftword)){  \n            return arr[mid].ewords;  \n        }  \n        else if(strcmp(id,arr[mid].ftword)>0)  \n            low=mid+1;  \n        else  \n            high=mid-1;  \n    }  \n    return NULL;  \n  \n}  \nint main(){  \n    int m=0;  \n    char line[30];  \n    for(m=0;gets(line)&&strlen(line);m++){  \n        sscanf(line,\"%s%s\",arr[m].ewords,arr[m].ftword);  \n    }  \n    qsort(arr,m,sizeof(arr[0]),cmp);  \n    while(gets(line)&&strlen(line)){  \n        char *p=dsearch(line,0,m);  \n        if(p) printf(\"%s\\n\",p);  \n        else printf(\"eh\\n\");  \n    }  \n    return 0;  \n}  \n```","tags":["ACM&OJ"]},{"title":"两道基础线段树简解:HDU 1166，HDU 1754","url":"/2015/07/22/两道基础线段树简解:HDU 1166，HDU 1754/","content":"\n今天刚学了下线段树，感觉如果想快速攻入熟练的程度还是需要时间的，不过看了几题之后发现这些还是有规律的，或许是我们所说的模板吧。但是还是很多难题不能解出来的。还有就是，我感觉上来，树的算法还是比较依靠空间的（不知是不是我做的优化还不够）。写下两道简单的题目，供自己记忆和理解，有兴趣的朋友也可以看看，帮忙斧正斧正。\n\n接下来的两道题我也想了很久，看了许多朋友写的代码，好不容易才磨出来。我还要加油了！\nDHU 1166 敌兵布阵\n\n敌兵布阵\nTime Limit:1000MS     Memory Limit:32768KB     64bit IO Format:%I64d & %I64u\nSubmitStatus\n\nDescription\n C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。 \n中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:\"你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：\"我知错了。。。\"但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. \n\nInput\n第一行一个整数T，表示有T组数据。 \n每组数据第一行一个正整数N（N<=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1<=ai<=50）。 \n接下来每行有一条命令，命令有4种形式： \n(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30） \n(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）; \n(3)Query i j ,i和j为正整数,i<=j，表示询问第i到第j个营地的总人数; \n(4)End 表示结束，这条命令在每组数据最后出现; \n每组数据最多有40000条命令 \nOutput\n\n\n\n\n对第i组数据,首先输出“Case i:”和回车, \n对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 \n\n\nSample Input\n\n\n1\n10\n1 2 3 4 5 6 7 8 9 10\nQuery 1 3\nAdd 3 6\nQuery 2 7\nSub 10 2\nAdd 6 3\nQuery 3 10\nEnd \n   \n\n\n\n\nSample Output\n\n\n\n\nCase 1:\n6\n33\n59 \n\n```C\n#include <iostream>  \n#include <cstring>  \n#include <cstdio>  \n#define MAXN 50000+5  \nusing namespace std;  \n  \nint sumOfPeople[MAXN];  \nlong long Qsum;  \n  \nstruct Tree{  \n    int l;  \n    int r;  \n    int sum;  \n}node[4*MAXN];              //线段树记得开到原来MAXN的4倍,其实消耗好像并没有这么大。  \n  \nvoid build(int x,int y,int i){  //建树，线段树很多思想都用到二分的方法  \n    node[i].l=x;  \n    node[i].r=y;  \n    if(x==y) node[i].sum=sumOfPeople[y];//当y==x时，到达最底下node,有的朋友习惯在这里用scanf读入数据。  \n    else{  \n        build(x,(x+y)/2,i<<1);           //x+y/2为左边子树的右端点，(x+y)/2+1为右端树左端点  \n        build((x+y)/2+1,y,i<<1|1);       //node下标变为i*2和i*2+1  \n        node[i].sum=node[i+i].sum+node[i+i+1].sum;  \n    }  \n}  \nvoid query(int x,int y,int i){          //询问  \n    if(x<=node[i].l&&y>=node[i].r)      //找到后修改全局变量  \n        Qsum+=node[i].sum;  \n    else{  \n        int mid=(node[i].l+node[i].r)/2;//否则左右查找  \n        if(x>mid) query(x,y,i+i+1);  \n        else if(y<=mid) query(x,y,i+i);  \n        else{  \n            query(x,y,i+i);             //记得不在某一边时两边都要查找  \n            query(x,y,i+i+1);  \n        }  \n    }  \n}  \nvoid add(int x,int y,int i){  \n    node[i].sum+=y;  \n    if(node[i].l==x&&node[i].r==x) return;  \n    if(x>(node[i].l+node[i].r)/2) add(x,y,i+i+1);  \n    else add(x,y,i+i);  \n}  \nvoid sub(int x,int y,int i)  {  \n    node[i].sum-=y;  \n    if(node[i].l==x&&node[i].r==x) return;  \n    if(x>(node[i].l+node[i].r)/2) sub(x,y,i+i+1);  \n    else sub(x,y,i+i);  \n}  \nint main()  \n{  \n    int times=1;  \n    int T;  \n    scanf(\"%d\",&T);  \n    while(T--){  \n        printf(\"Case %d:\\n\",times++);  \n        int N;  \n        scanf(\"%d\",&N);  \n        for(int i=1;i<=N;i++)  \n            scanf(\"%d\",&sumOfPeople[i]);  \n        build(1,N,1);  \n        char key[10];  \n        //scanf(\"\\n\");  \n        while(scanf(\" %s\",key)&&key[0]!='E'){//\" %s\"前的空格用于清空缓冲区  \n            int a,b;  \n            scanf(\"%d%d\",&a,&b);  \n            if(strcmp(key,\"Query\")==0){  \n                Qsum=0;  \n                query(a,b,1);  \n                cout<<Qsum<<endl;  \n            }  \n            else if(strcmp(key,\"Add\")==0)  \n                add(a,b,1);  \n            else if(strcmp(key,\"Sub\")==0)  \n                sub(a,b,1);  \n            //printf(\"%s\\n\",key);  \n            //scanf(\"\\n\");  \n        }  \n    }  \n    return 0;  \n}  \n```\n下面这题是线段树的另一种用法：找max/min值\n\n\nI Hate It\nTime Limit:3000MS     Memory Limit:32768KB     64bit IO Format:%I64d & %I64u\nSubmitStatus\n\nDescription\n\n很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。 \n这让很多学生很反感。 \n\n不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 \n\nInput\n本题目包含多组测试，请处理到文件结束。 \n在每个测试的第一行，有两个正整数 N 和 M ( 0<N<=200000,0<M<5000 )，分别代表学生的数目和操作的数目。 \n学生ID编号分别从1编到N。 \n第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 \n接下来有M行。每一行有一个字符 C (只取'Q'或'U') ，和两个正整数A，B。 \n当C为'Q'的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 \n当C为'U'的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 \n\nOutput\n对于每一次询问操作，在一行里面输出最高成绩。 \n\nSample Input\n\n5 6\n1 2 3 4 5\nQ 1 5\nU 3 6\nQ 3 4\nQ 4 5\nU 2 9\nQ 1 5 \n\nSample Output\n\n5\n6\n5\n9 \n\n\n Hint\n\n\nHuge input,the C function scanf() will work better than cin \n\n代码和上题类似\n\n```C\n#include <iostream>  \n#include <cstring>  \n#include <cstdio>  \n#include <cmath>  \n#define MAX 200000+10  \n  \nusing namespace std;  \n  \nint stu[MAX];  \nint MaxMarks=0;  \nstruct Tree{  \n    int l;  \n    int r;  \n    int maxn;  \n}node[4*MAX];  \n//建树，最简单的一部分。  \nvoid build(int x,int y,int i){  \n    node[i].l=x;  \n    node[i].r=y;  \n    if(x==y){ node[i].maxn=stu[x];return ;}  \n    int mid=(x+y)/2;  \n    build(x,mid,i+i);  \n    build(mid+1,y,i+i+1);  \n    node[i].maxn=max(node[i+i+1].maxn,node[i+i].maxn);  \n}  \n  \n//询问函数：这边有一点我也不太清楚，写出void修改全局变量好像更快一些  \nint query(int x,int y,int i){  \n    if(x==node[i].l&&node[i].r==y)  \n        return node[i].maxn;  \n    int mid=(node[i].r+node[i].l)>>1;  \n    if(x>mid) return query(x,y,i+i+1);  \n    else if(y<=mid) return query(x,y,i+i);  \n    else  \n        return max(query(x,mid,i+i),query(mid+1,y,i+i+1));  \n}  \n  \nvoid upData(int x,int y,int i,int tmp){  \n    if(x== node[i].l && y==node[i].r){  \n        node[i].maxn = tmp;  \n        return;  \n    }  \n    int mid =(node[i].l + node[i].r)>>1;  \n    if(y <= mid)  \n        upData(x,y,i<<1,tmp);  \n    else if(x>mid)  \n        upData(x,y,i<<1|1,tmp);  \n    else {  \n        upData(x,mid,i<<1,tmp);  \n        upData(mid+1,y,i<<1|1,tmp);  \n    }  \n    node[i].maxn = max(node[i<<1].maxn,node[i<<1|1].maxn); //更新完单个点之后更新整棵树  \n}  \n  \nint main()  \n{  \n    int N,T;  \n    while(~scanf(\"%d%d\",&N,&T)){  \n        for(int i=1;i<=N;i++)  \n            scanf(\"%d\",&stu[i]);  \n        build(1,N,1);  \n        while(T--){  \n            char c;  \n            int a,b;  \n            scanf(\" %c%d%d\",&c,&a,&b);  \n            //cout << \"a=\"<<a<<\" b=\"<<b<<endl;  \n            if(c=='Q') cout << query(a,b,1)<<endl;  \n            else upData(a,a,1,b);  \n        }  \n    }  \n    return 0;  \n}  \n```\n\n","tags":["ACM&OJ"]},{"title":"ExtendGcd,即扩展欧几里得算法的C++模板化解释","url":"/2015/07/21/ExtendGcd,即扩展欧几里得算法的C++模板化解释/","content":"\n刚刚接触感觉很高大上的“扩展欧几里得算法“，很郁闷，研究了很久。现在感觉能够套模板了，当然这样是远远不够的，不过先写篇博客记录一下最近的动态。帮助自己记忆，也可以帮助大家理解下这个数学算法，当然欢迎各位的斧正和指点，我将不断努力！\n\n首先，明确我们要求ax+by=c中x,y的整数解（至于没有解的情况下边会讨论）\n\n大家应该看到过ax+by=Gcd(a,b)的式子，现在我也不明白这是什么，以下是我大概能够死记硬背的（大家能学会的还是去学学原理）。\n\n先求gcd(a,b),程序如下:\n\n\n```C\ntypedef long long LL;  \nusing namespace std;  \n  \nLL gcd(LL a,LL b){  \n    while(a%b){  \n        LL temp=b;  \n        b=a%b;  \n        a=temp;  \n    }  \n    return b;  \n}  \n```\nLL d=gcd(a,b);\n后，a/=d,b/=d,c/=d;这里有当c%d!=0是，ax+by=c不存在整数解（我也不知道为什么，真的模板化了)\n\n于是原式变成a'x+b'y=c'。据说那个扩展欧几里得求的是a'x+b'y=1的解，给出extendGcd(a,b)的模板\n\n\n```C\nvoid exGcd(LL a,LL b,LL &x,LL &y){\n    if(b==0){\n        x=1;y=0;  \n        return ;  \n    } \n    exGcd(b,a%b,x,y); \n        LL temp;  \n        temp=y;  \n        y=x-a/b*y;  \n        x=temp;  \n}\n```\n这里不难得到修改后的x,y为方程a'x+b'y=1的解，那么c'x0,c'y0就是a'x+b'y=c'的一组特解了，根据参数方程的性质，我们引入t（整数）来写出x,y通解的参数方程x=c'x0-b't，y=c'y0+a't。\n通常题目要求我们求问题的最小解，所以当x->0时，我们求出的t=c'x0/b(这里是有误差的，因为在C语言中的除不一定，事实上，我们可以判断下x<0时，可以让t=t+1。\n\n下面来看一道典型的模板题吧。\n\npoj 1061 \n\n\n青蛙的约会\nTime Limit: 1000MS\t \tMemory Limit: 10000K\nTotal Submissions: 96453\t \tAccepted: 18021\nDescription\n\n两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 \n我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 \nInput\n\n输入只包括一行5个整数x，y，m，n，L，其中x≠y < 2000000000，0 < m、n < 2000000000，0 < L < 2100000000。\nOutput\n\n输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行\"Impossible\"\nSample Input\n1 2 3 4 5\nSample Output\n4\n\n```C\n#include <iostream>  \n#include <cstdio>  \n  \ntypedef long long LL;  \nusing namespace std;  \n  \nLL gcd(LL a,LL b){  \n    while(a%b){  \n        LL temp=b;  \n        b=a%b;  \n        a=temp;  \n    }  \n    return b;  \n}  \n  \nvoid exGcd(LL a,LL b,LL &x,LL &y){  \n    if(b==0){  \n        x=1;y=0;  \n        return ;  \n    }  \n    exGcd(b,a%b,x,y);  \n        LL temp;  \n        temp=y;  \n        y=x-a/b*y;  \n        x=temp;  \n}  \nint main()  \n{  \n    LL x,y,m,n,l,ans,key,t;  \n    while(~scanf(\"%I64d%I64d%I64d%I64d%I64d\",&x,&y,&m,&n,&l)){  \n        /* (n-m)*ans+k*l=x-y; \n         * n-m=a,ans=x,k=y,l=b,x-y=c; \n         *   a*x+b*y=c; \n         */  \n        LL a=n-m,b=l,c=x-y;  \n        LL d=gcd(a,b);  \n        //cout <<  d  <<endl;  \n        if(c%d) {printf(\"Impossible\\n\");continue;}  \n  \n        a/=d;b/=d;c/=d;  \n        exGcd(a,b,ans,key);  \n  \n        t=c*ans/b;  \n        ans=c*ans-t*b;  \n        if(ans<0)  \n            ans+=b;  \n        printf(\"%I64d\\n\",ans);  \n    }  \n    return 0;  \n}  \n```","tags":["ACM&OJ"]},{"title":"(转) KMP算法详解：简洁易懂的KMP算法","url":"/2015/07/20/[转载]KMP算法详解：简洁易懂的KMP算法/","content":"转自 http://www.matrix67.com/blog/archives/115\n\n（Matrix67原创）\n\n如果机房马上要关门了，或者你急着要和MM约会，请直接跳到第六个自然段。\n\n我们这里说的KMP不是拿来放电影的（虽然我很喜欢这个软件），而是一种算法。KMP算法是拿来处理字符串匹配的。换句话说，给你两个字符串，你需要回答，B串是否是A串的子串（A串是否包含B串）。比如，字符串A=\"I'm matrix67\"，字符串B=\"matrix\"，我们就说B是A的子串。你可以委婉地问你的MM：“假如你要向你喜欢的人表白的话，我的名字是你的告白语中的子串吗？”\n    \n解决这类问题，通常我们的方法是枚举从A串的什么位置起开始与B匹配，然后验证是否匹配。假如A串长度为n，B串长度为m，那么这种方法的复杂度是O (mn)的。虽然很多时候复杂度达不到mn（验证时只看头一两个字母就发现不匹配了），但我们有许多“最坏情况”，比如，A= \"aaaaaaaaaaaaaaaaaaaaaaaaaab\"，B=\"aaaaaaaab\"。我们将介绍的是一种最坏情况下O(n)的算法（这里假设 m<=n），即传说中的KMP算法。\n\n之所以叫做KMP，是因为这个算法是由Knuth、Morris、Pratt三个提出来的，取了这三个人的名字的头一个字母。这时，或许你突然明白了AVL 树为什么叫AVL，或者Bellman-Ford为什么中间是一杠不是一个点。有时一个东西有七八个人研究过，那怎么命名呢？通常这个东西干脆就不用人名字命名了，免得发生争议，比如“3x+1问题”。扯远了。\n\n个人认为KMP是最没有必要讲的东西，因为这个东西网上能找到很多资料。但网上的讲法基本上都涉及到“移动(shift)”、“Next函数”等概念，这非常容易产生误解（至少一年半前我看这些资料学习KMP时就没搞清楚）。在这里，我换一种方法来解释KMP算法。\n\n假如，A=\"abababaababacb\"，B=\"ababacb\"，我们来看看KMP是怎么工作的。我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前 j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]<>B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B = a b a b a c b\n    j = 1 2 3 4 5 6 7\n```\n此时，A[6]<>B[6]。这表明，此时j不能等于5了，我们要把j改成比它小的值j'。j'可能是多少呢？仔细想一下，我们发现，j'必须要使得B[1..j]中的头j'个字母和末j'个字母完全相等（这样j变成了j'后才能继续保持i和j的性质）。这个j'当然要越大越好。在这里，B [1..5]=\"ababa\"，头3个字母和末3个字母都是\"aba\"。而当新的j为3时，A[6]恰好和B[4]相等。于是，i变成了6，而j则变成了 4：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =     a b a b a c b\n    j =     1 2 3 4 5 6 7\n```\n从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当匹配到B数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。P[j]应该是所有满足B[1..P[j]]=B[j-P[j]+1..j]的最大值。\n再后来，A[7]=B[5]，i和j又各增加1。这时，又出现了A[i+1]<>B[j+1]的情况：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =     a b a b a c b\n    j =     1 2 3 4 5 6 7\n```\n由于P[5]=3，因此新的j=3：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =         a b a b a c b\n    j =         1 2 3 4 5 6 7\n```\n这时，新的j=3仍然不能满足A[i+1]=B[j+1]，此时我们再次减小j值，将j再次更新为P[3]：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =             a b a b a c b\n    j =             1 2 3 4 5 6 7\n```\n现在，i还是7，j已经变成1了。而此时A[8]居然仍然不等于B[j+1]。这样，j必须减小到P[1]，即0：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =               a b a b a c b\n    j =             0 1 2 3 4 5 6 7\n```\n终于，A[8]=B[1]，i变为8，j为1。事实上，有可能j到了0仍然不能满足A[i+1]=B[j+1]（比如A[8]=\"d\"时）。因此，准确的说法是，当j=0了时，我们增加i值但忽略j直到出现A[i]=B[1]为止。\n这个过程的代码很短（真的很短），我们在这里给出：\n```bash\nj:=0;\nfor i:=1 to n do\nbegin\n   while (j>0) and (B[j+1]<>A[i]) do j:=P[j];\n   if B[j+1]=A[i] then j:=j+1;\n   if j=m then\n   begin\n      writeln('Pattern occurs with shift ',i-m);\n      j:=P[j];\n   end;\nend;\n```\n最后的j:=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配。\n\n这个程序或许比想像中的要简单，因为对于i值的不断增加，代码用的是for循环\n。因此，这个代码可以这样形象地理解：扫描字符串A，并更新可以匹配到B的什么位置。\n\n\n现在，我们还遗留了两个重要的问题：一，为什么这个程序是线性的；二，如何快速预处理P数组。\n\n为什么这个程序是O(n)的？其实，主要的争议在于，while循环使得执行次数出现了不确定因素。我们将用到时间复杂度的摊还分析中的主要策略，简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。KMP的时间复杂度分析可谓摊还分析的典型。我们从上述程序的j 值入手。每一次执行while循环都会使j减小（但不能减成负的），而另外的改变j值的地方只有第五行。每次执行了这一行，j都只能加1；因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。这告诉我们，while循环总共最多执行了n次。按照摊还分析的说法，平摊到每次for循环中后，一次for循环的复杂度为O(1)。整个过程显然是O(n)的。这样的分析对于后面P数组预处理的过程同样有效，同样可以得到预处理过程的复杂度为O(m)。\n\n预处理不需要按照P的定义写成O(m<sup>2</sup>) 甚至 O(m<sup>3</sup>)的。我们可以通过P[1],P[2],…,P[j-1]的值来获得P[j]的值。对于刚才的B=\"ababacb\"，假如我们已经求出了P[1],P[2],P[3]和P[4]，看看我们应该怎么求出P[5]和P[6]。P[4]=2，那么P [5]显然等于P[4]+1，因为由P[4]可以知道，B[1,2]已经和B[3,4]相等了，现在又有B[3]=B[5]，所以P[5]可以由P[4] 后面加一个字符得到。P[6]也等于P[5]+1吗？显然不是，因为B[ P[5]+1 ]<>B[6]。那么，我们要考虑“退一步”了。我们考虑P[6]是否有可能由P[5]的情况所包含的子串得到，即是否P[6]=P[ P[5] ]+1。这里想不通的话可以仔细看一下：\n```bash\n        1 2 3 4 5 6 7\n    B = a b a b a c b\n    P = 0 0 1 2 3 ?\n```\n\nP[5]=3是因为B[1..3]和B[3..5]都是\"aba\"；而P[3]=1则告诉我们，B[1]、B[3]和B[5]都是\"a\"。既然P[6]不能由P[5]得到，或许可以由P[3]得到（如果B[2]恰好和B[6]相等的话，P[6]就等于P[3]+1了）。显然，P[6]也不能通过P[3]得到，因为B[2]<>B[6]。事实上，这样一直推到P[1]也不行，最后，我们得到，P[6]=0。\n\n怎么这个预处理过程跟前面的KMP主程序这么像呢？其实，KMP的预处理本身就是一个B串“自我匹配”的过程。它的代码和上面的代码神似：\n```bash\nP[1]:=0;\nj:=0;\nfor i:=2 to m do\nbegin\n   while (j>0) and (B[j+1]<>B[i]) do j:=P[j];\n   if B[j+1]=B[i] then j:=j+1;\n   P[i]:=j;\nend;\n```\n最后补充一点：由于KMP算法只预处理B串，因此这种算法很适合这样的问题：给定一个B串和一群不同的A串，问B是哪些A串的子串。\n\n串匹配是一个很有研究价值的问题。事实上，我们还有后缀树，自动机等很多方法，这些算法都巧妙地运用了预处理，从而可以在线性的时间里解决字符串的匹配。我们以后来说。\n\n昨天发现一个特别晕的事，知道怎么去掉BitComet的广告吗？把界面语言设成英文就行了。\n还有，金山词霸和Dr.eye都可以去自杀了，Babylon素王道。\n\nMatrix67原创\n转贴请注明出处","tags":["ACM&OJ"]},{"title":"HDU 2181 哈密顿绕行世界问题","url":"/2015/07/13/HDU 2181 哈密顿绕行世界问题/","content":"\n看到挺多人在写博客的，我也想来学习学习，接触ACM也快1年了吧，不过到现在还是个渣渣，不过正在努力提高！\n\n写的第一篇博客，哈密顿绕行世界问题：深度搜索问题（深搜）。与一般的地图找点（找出口问题）相似，只是搜索过程中需要记录每次走过的点，便于输出。题目如下：高手别喷，如有雷同，请勿见怪。\n\n题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=2181<link>\n\n\n``` bash\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n  \nconst int MAXN=21;  \n  \nusing namespace std;  \n  \nint way[MAXN];          //保存每次走过的城市  \nint sumWays=0;          //记录总共有多少方案  \nint cas;  \nbool mp[MAXN][MAXN];    //保存原始输入数据  \nbool used[MAXN];        //判断该点（城市）是否被用过  \n  \nvoid inPut(){  \n    int a,b,c;  \n    for(int i=1;i<=20;i++){  \n        scanf(\"%d%d%d\",&a,&b,&c);  \n        mp[i][a]=true;  //表示与i城市连通的城市a,b,c。（数组特殊用法  \n        mp[i][b]=true;  \n        mp[i][c]=true;  \n    }  \n}  \n  \nvoid dfs(int nowStep,int count){  \n    way[count]=nowStep;             //当前计数走的城市编号，便于输出  \n    if(count==19){                  //搜索结束条件：当20个城市全部走完时  \n        if(mp[nowStep][cas]){       //若能够回到原点，则输出  \n            printf(\"%d:  \", ++ sumWays);  \n            for(int i = 0; i < 20; ++ i){  \n                printf(\"%d \", way[i]);  \n            }  \n            printf(\"%d\\n\", way[0]);  \n        }  \n    }  \n    else{  \n        for(int j = 1; j <= 20; j ++){  //找某条路是否连通，且通往该城市未被走过  \n            if(mp[nowStep][j] && !used[j]){  \n                used[j] = true;  \n                dfs(j, count+1);  \n                used[j] = false;    //记得消除！  \n            }  \n        }  \n    }  \n    return ;  \n}  \n  \nint main()  \n{  \n    memset(mp,false,sizeof(mp));  \n    inPut();  \n    while(scanf(\"%d\",&cas)&&cas){  \n        sumWays=0;  \n        memset(used,false,sizeof(used));  \n        //memset(way,0,sizeof(mp));  \n        used[cas]=true;  \n        dfs(cas,0); //深搜递归  \n    }  \n    return 0;  \n}  \n\n```","tags":["ACM&OJ"]}]